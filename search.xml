<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高斯消元法]]></title>
    <url>%2FBlog%2Farchives%2Feccd8894.html</url>
    <content type="text"><![CDATA[高斯消元法介绍 高斯消元法主要用在解线性方程，当前实现的仅仅是有唯一解的一个算法1234x1 x2 x3 val1 2 3 53 4 4 73 4 5 6 将线性方程变成一个上三角矩阵的过程1 2 3 3 40 1 2 3 40 0 1 2 30 0 0 3 3 从这个矩阵也不难看出是一个n x (n+1)类型 实现步骤 实现上三角转换主要是进行遍历，遍历的过程主要就是让每行的参数变为0 第一行遍历剩下的n-1行第二行遍历剩下的n-2行…所有行都遍历 上三角转换后，计算参数这里可以利用 n x (n+1)这一特性 python源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#coding=UTF-8###高斯消元法实现#############def Gauss(data): ##i是列元素j是控制循环的次数，line是存储一行元素 i=0 j=0 line_size=len(data) while j&lt;line_size-1: ###得到数据中的行 line=data[j] temp=data[j][j] templete=[] for x in line: x=x/temp templete.append(x) data[j]=templete flag=j+1 ######遍历第1行以后的行 while flag&lt;line_size: templete1=[] temp1=data[flag][j] i=0 ####将行的每一个元素与第一行相减 for x1 in data[flag]: if x1 !=0: x1=x1-(temp1*templete[i]) templete1.append(x1) else: templete1.append(0) i+=1 data[flag]=templete1 flag+=1 ##第一个参数已经消去，遍历消去剩下的参数 j+=1 #################对得到的上三角矩阵计算参数########### ''' [1,2,3,4,5 0,2,3,4,5 0,0,4,5,6 0,0,0,1,3 ] ''' parameter=[] parameter.append(data[line_size-1][-1]/data[line_size-1][-2]) ##parameter的下标刚好是所有参数剪切 #####从倒数第二列开始计算参数# i=line_size-2 while i &gt;=0: sum=0 parameter1=0 #这里分别进行回带，通过paramete数组 for j in range(i+1,line_size): sum+=parameter[line_size-1-j]*data[i][j] parameter1=(data[i][-1]-sum)/data[i][i] parameter.append(parameter1) i=i-1 return(parameter)#####进行消元测试#######parameters=[[6,15, 55,152.6],[15, 55, 225, 585.6],[55,225,979,2488.8] ]results=Gauss(parameters)print("x1="+str(results[-1])+"\nx2="+str(results[-2])+"\nx3="+str(results[0])+"\n") 总结其实思想很简单，代码实现的时候有一些小技巧 关于python画图的画等有时间再进行摸索吧 参考 https://blog.csdn.net/deramer1/article/details/79049625]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小二乘python实现]]></title>
    <url>%2FBlog%2Farchives%2F6c33c6ae.html</url>
    <content type="text"><![CDATA[什么是最小二乘法通常用来对改定数据集D做线性回归，找到一条最逼近整个数据集的直线；在这里我只使用了一个属性到y的映射，其实也有多个属性可以同时进行映射，就需要用到降维的思想，例如我们有一对刮南瓜、西瓜、黄瓜；既可以使用三个坐标系将它们进行刻画。 让拟合直线上的每一个点距离D中的点的离均差的误差最小 limit1m(f(xi)-yi)2 推理步骤 当所有样本到直线上的点最小时，相当于对K和b求偏导为0 分别对k和b的公式进行转换，得到k和b的值 我发现它必定要过（x,y）的平均值的那个点 python实现12345678910111213141516171819202122232425262728293031323334353637383940#coding=UTF-8&apos;&apos;&apos;进行一元数据的拟合&apos;&apos;&apos;x=[1,2,3,4,5,6,7]y=[3,4,5,6,7,8,9]###计算拟合参数######def lineFitting(data_x,data_y): ###获取集合中样本数目 size=len(data_x) ##构造遍历索引变量 i=0 ###声明公式中的变量 sum_x=0 sum_y=0 sum_Xsquare=0 sum_xy=0 average_x=0 average_y=0 ######对各个变量进行赋值 while i&lt;size: sum_x+=data_x[i] sum_y+=data_y[i] sum_Xsquare+=data_x[i]*data_x[i] sum_xy+=data_x[i]*data_y[i] i+=1 average_x=sum_x/size average_y=sum_y/size ###获取各个参数后直接套公式#### k=(sum_xy-sum_y*average_x)/(sum_Xsquare-sum_x*average_x) b=average_y-k*average_x return [k,b]#########计算拟合后的参数#########fittingParameter=lineFitting(x,y)print(&quot;y=&quot;+str(fittingParameter[0])+&quot;*x&quot;+&quot;+&quot;+str(fittingParameter[1])+&quot;\n&quot;) 绘图最后本来打算画一个图的，但是在服务器上跑脚本，图片就算了吧]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】关于hexo博客的搭建]]></title>
    <url>%2FBlog%2Farchives%2Fd86fd5e9.html</url>
    <content type="text"><![CDATA[Quick start关于如何进行安装hexo和一些配置插件的过程我这里就不详细介绍了；大家可以百度网上一大堆，当然我这里推荐一些讲的比较好的博客遇见西门里面介绍了如何进行hexo的安装与主题的优化 插件的配置我使用的是gitment，还是对github比较有好感，具体教程参考：gitment 永久链接的配置借助于hexo-abbrlink插件，安装好之后呢；在博客目录下的配置文件中修改_config.yml文件就ok，具体的修改方式如下1234permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 rep: hex 参考 关于在github二级仓库中构建博客 首先是在博客目录下的配置文件中进行设置 12url: https://zpliu1126.github.io/hexoTestroot: /hexoTest/ 接着就是关于搜素插件如何找到对应文件路径设置 12/*#######设置数据库所在文件*/xhr.open('GET', '/hexoTest/content.json', true); 由于该主题作者 Snippet并没有考虑到这一情况，我是在获取conten.js的路径中进行了修改 对应找到对应的数据文件之后进行路径的构造12/*关于在搜素结果content.json获取数据后加上子repository名构造最后url*/ path: "hexoTest/"+post.path, 其实就是一个字符串拼接的过程 关于文章如何进行分类的问题 1.在theme配置文件中打开category和tag标签 2.接着在每一个生成的文章中需要定义好category和tag内容才能进行跳转 3.同时在theme配置文件中可以定义好一些目录的跳转链接 123456789101112131415161718192021 #########文章的开头########## ---title: 关于hexo博客的搭建abbrlink: d86fd5e9date: 2019-03-05 18:06:07category: computerLanguagetag: - JavaScript - html - css---######导航栏##########menu:- page: home url: /hexoTest icon:- page: 计算机程序 url: /hexoTest/categories/computerLanguage/ icon:- page: Bioinformatic url: /hexoTest/categories/Bioinformatic/ 添加背景音乐 首先在网页版网易云找到喜欢的音乐，点击添加外部播放器有html和flash版本 我选择html版本，然后在theme的部署文件里随便找了个地方放了进去 最后调整播放框的大小]]></content>
      <categories>
        <category>computerLanguage</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Blast教程]]></title>
    <url>%2FBlog%2Farchives%2Fd57c3785.html</url>
    <content type="text"><![CDATA[blast+安装 通过wget 命令直接下载到本地服务器中 1wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/ncbi-blast-2.2.30+-x64-linux.tar.gz 对下载好的文件进行解压 1tar -zxvf ncbi-blast-2.2.30+-x64-linux.tar.gz 解压之后，其实就可以使用绝对路径使用blast+了；怎么知道blast的绝对路径呢 123pwd ncbi-blast-2.2.30+-x64-linux.tar.gz/bin ######例如我们得到这样的绝对路径##########/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin/ 这条命令就得到了我们blast可执行程序所在的绝对路径，也就是在电脑上的哪个文件夹 有了绝对路径我们就可以告诉计算机到哪里去找balst程序来执行当执行blastn核苷酸比对程序时直接使用下面的命令就可以执行了1/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin/blastn 添加可执行程序到环境变量中 首先环境变量是啥？环境变量其实就是一个变量，这个变量里面包括一个叫$PATH的变量，里面存储着一些你想告诉计算机的东西。比如我想告诉计算机blast+的所有可执行的程序都放在哪个文件里面，我只需要在$PATH这个变量中加上blast/bin的文件夹；这样当我们在计算机的任何地方想要执行balst的时候只需要按下blastn或者其他命令就行了12echo &quot;export PATH=/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin:\$PATH&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc blast的使用构建本地blast库例如要构建核酸库，使用整个CDS构建的基因序列库1makeblastdb -in &quot;CDS文件&quot; -dbtype &quot;nucl&quot; -parse_seqids -out &quot;库名称的前缀&quot; 具体参数的意义可以使用 -help参数查看手册，我就不多做赘述同理构建蛋白库1makeblastdb -in &quot;氨基酸序列文件&quot; -dbtype &quot;prot&quot; -parse_seqids -out &quot;库名称的前缀&quot; 进行序列比对 首先我们需要准备比对的fasta文件，然后一条命令就可以了1blastn -query &quot;需要比对的文件&quot; -db &quot;上一步建好的库的目录加上/库前缀&quot; -evalue 1e-5 -outfmt 6 -out &quot;输出文件&quot; 这里的outfmt是输出文件的格式，包括1-10种格式 具体参数的意义，可以使用–help参数查看]]></content>
      <categories>
        <category>Bioinformatic</category>
      </categories>
      <tags>
        <tag>Blast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型评估与选择]]></title>
    <url>%2FBlog%2Farchives%2F7d1dcda7.html</url>
    <content type="text"></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础篇]]></title>
    <url>%2FBlog%2Farchives%2F53d0684b.html</url>
    <content type="text"></content>
      <categories>
        <category>computerLanguage</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Circos其实很简单]]></title>
    <url>%2FBlog%2Farchives%2F87ef918.html</url>
    <content type="text"></content>
      <categories>
        <category>Bioinformatic</category>
      </categories>
      <tags>
        <tag>Circos学习</tag>
      </tags>
  </entry>
</search>
