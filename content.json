{"meta":{"title":"ZpliuBlog","subtitle":null,"description":null,"author":"zpliu","url":"https://zpliu1126.github.io/Blog","root":"/Blog/"},"pages":[{"title":"Music","date":"2019-03-09T11:16:49.000Z","updated":"2019-03-09T11:29:14.236Z","comments":true,"path":"Music/index.html","permalink":"https://zpliu1126.github.io/Blog/Music/index.html","excerpt":"","text":"Music L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/Blog/live2dw/assets/z16.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":false}});"},{"title":"tags","date":"2019-03-03T05:34:48.000Z","updated":"2019-03-05T04:24:33.442Z","comments":true,"path":"tags/index.html","permalink":"https://zpliu1126.github.io/Blog/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-05T09:43:46.000Z","updated":"2019-03-05T09:43:46.211Z","comments":true,"path":"categories/index.html","permalink":"https://zpliu1126.github.io/Blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"基因家族分析流程","slug":"基因家族分析流程","date":"2019-03-12T07:55:35.000Z","updated":"2019-03-13T14:28:30.242Z","comments":true,"path":"archives/ba1fe7ba.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/ba1fe7ba.html","excerpt":"","text":"家族基因聚类分析流程首先获取到各个物种中对应的基因编号，并且得到对应的基因序列、氨基酸序列 序列保守性使用MEGA软件进行进化分析，提取各个物种中的氨基酸序列进行比对;MEGA中Alig by ClustalW 子程序得到结果如下: 进行聚类分析使用上一步比对好的mas后缀输出文件，构建进化树构建好进化树就可以输出树形状格式了，文件后缀为nwk (GhirD03G004880,Gorai.003G049300|CESA6),GhirA11G023630),); iTOL画进化树具体的学习方法花个1个小时的时间，看官网的视频就很清楚啦1.在cotrol面板中有所有的控制参数2.当需要添加数据集的时候，需要点击对应的分子进行添加，添加之后可以在控制面板进行参数的设置3.进行设置的时候可以使用粘贴功能 最后大功告成 Reference颜色搭配颜色搭配2iTOL","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[]},{"title":"LDA线性判别分析","slug":"LAD线性判别分析","date":"2019-03-08T14:07:34.000Z","updated":"2019-03-11T10:11:26.540Z","comments":true,"path":"archives/3a6e9ae0.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/3a6e9ae0.html","excerpt":"","text":"LAD概括LAD主要用于在高维数据的分类中，将数据按照线性模型进行降维；使得数据得到很好的分类同时避免数据过度拟合，与PAC不同的是 LAD主要用于有监督的学习，用于对目标分类;约束条件则是类间的协方差最大，同类内的协方差最小化PAC则是无监督的学习，将样本投影到几个正交的方向，同时同类内的方差越大越好，尽可能的保留样本的全部信息 两类的LAD问题可以看作是把所有样本都投影到一个方向上，然后在这个一维空间中确定一个分类的阈值。过这个阈值点且与投影方向垂直的超平面就是两类的分类面。 公式推导 映射直线y=wTx 约束条件则是类间的协方差最大，同类内的协方差最小化 J=||wTμ0−wTμ1||22/wT(∑0+∑1)w=wT(μ0−μ1)(μ0−μ1)Tw/wT(∑0+∑1)w 这里涉及到欧氏距离也就是矩阵的平方等于 原矩阵*矩阵的转置 目的使得约束条件J最大化类间协方差矩阵 Sb=(μ0−μ1)(μ0−μ1)T类间协方差矩阵 Sw=∑x∈D0(x−μ0)(x−u0)T+∑x∈D1(x−μ1)(x−u1)T重写J: J=wTSbw/wTSww 关于W的确定，由于分子分母是w的平方，已经将w实数化；因此方程的解与w的大小已经无关，仅仅是方向上有关了 拉格朗日乘子法令wTSww=1c(w)=wTSbw−λ(wTSww−1)涉及到矩阵的求导dc/dw=2Sbw−2λSww=0Sbw=λSwwSbW 类间散度矩阵 方向是固定的U0-U1w=Sw -1(u0-u1) 基于两个以上特征值的分类原理是一样的，在计算类间散度矩阵是多了两个参数SB=∑i=1-c Ni(mmi−mm)(mmi−mm)Tmm 是全局均值，而 mmi 和 Ni 是每类样本的均值和样本数。 求出特征值和特征序列矩阵 S−1WSB =W按照特征值排序，将原来多维度的空间映射到对应的空间 代码实现数据获取与格式整理#coding=UTF-8 import numpy as np import pandas as pd from sklearn.preprocessing import LabelEncoder from matplotlib import pyplot as plt ####构造索引与对应的名称关系 feature_dict = {i:label for i,label in zip( range(4), (&#39;sepal length in cm&#39;, &#39;sepal width in cm&#39;, &#39;petal length in cm&#39;, &#39;petal width in cm&#39;, ))} &#39;&#39;&#39; {0: &#39;sepal length in cm&#39;, 1: &#39;sepal width in cm&#39;, 2: &#39;petal length in cm&#39;, 3: &#39;petal width in cm&#39;} &#39;&#39;&#39; ##读取数据 df=pd.io.parsers.read_csv( filepath_or_buffer=&#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;, header=None, sep=&#39;,&#39;, ) ###定义列名 df.columns=[l for i,l in sorted(feature_dict.items())]+[&quot;classLab&quot;] #删除文件末尾的空行 df.dropna(how=&quot;all&quot;,inplace=True) ###看一下最后10行时啥样 #print(df.tail()) &#39;&#39;&#39; sepal length in cm sepal width in cm petal length in cm \\ 145 6.7 3.0 5.2 146 6.3 2.5 5.0 147 6.5 3.0 5.2 148 6.2 3.4 5.4 149 5.9 3.0 5.1 petal width in cm classLab 145 2.3 Iris-virginica 146 1.9 Iris-virginica 147 2.0 Iris-virginica 148 2.3 Iris-virginica 149 1.8 Iris-virginica &#39;&#39;&#39; 将类别数字化X=df[[0,1,2,3]].values #获取四种属性值 y=df[&#39;classLab&#39;].values #获取类别名 enc = LabelEncoder() label_encoder = enc.fit(y) y = label_encoder.transform(y) + 1 label_dict = {1: &#39;Setosa&#39;, 2: &#39;Versicolor&#39;, 3:&#39;Virginica&#39;} # print(len(y)) &#39;&#39;&#39; 数据处理完成 计算每类花对应的特征值的均值##分别对三种花求其在4种属性上的均值 np.set_printoptions(precision=4) mean_vectors=[] for i in range(1,4): ##对4中属性150 X 4 的矩阵按列求均值 mean_vectors.append(np.mean(X[y==i],axis=0)) #print(&#39;mean Vector calss %s: %s\\n&#39; %(i,mean_vectors[i-1])) &#39;&#39;&#39; mean Vector calss 1: [5.006 3.418 1.464 0.244] mean Vector calss 2: [5.936 2.77 4.26 1.326] mean Vector calss 3: [6.588 2.974 5.552 2.026] &#39;&#39;&#39; 类内散度矩阵S_W=np.zeros((4,4)) for cl,mv in zip(range(1,4),mean_vectors): ####每个类的类内散度矩阵 class_sc_mat=np.zeros((4,4)) for row in X[y==cl]: ##把对应的值与特征值进行运算 &#39;&#39;&#39; [1,第一个特征值 2, 第2个特征值 3, 第3个特征值 4 第4个特征值 ] &#39;&#39;&#39; row, mv = row.reshape(4,1), mv.reshape(4,1) class_sc_mat+=(row-mv).dot((row-mv).T) S_W+=class_sc_mat 类间散度矩阵overall_mean=np.mean(X,axis=0) S_b=np.zeros((4,4)) for i,men_vector in enumerate(mean_vectors): ###获取样本数目 n=X[y==i+1,:].shape[0] men_vector=men_vector.reshape(4,1) overall_mean=overall_mean.reshape(4,1) S_b+=n*(men_vector-overall_mean).dot((men_vector- overall_mean).T) print(&#39;between-class Scatter Matrix:\\n&#39;, S_b) 获取特征值和特征向量eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(S_W).dot(S_b)) for i in range(len(eig_vals)): eigvec_sc = eig_vecs[:,i].reshape(4,1) print(&#39;\\nEigenvector {}: \\n{}&#39;.format(i+1, eigvec_sc.real)) print(&#39;Eigenvalue {:}: {:.2e}&#39;.format(i+1, eig_vals[i].real)) 根据特征值大小选取特征向量降维eig_pairs = [(np.abs(eig_vals[i]), eig_vecs[:,i]) for i in range(len(eig_vals))] eig_pairs = sorted(eig_pairs, key=lambda k: k[0], reverse=True) W = np.hstack((eig_pairs[0][1].reshape(4,1), eig_pairs[1][1].reshape(4,1))) 映射到新的空间X_lda = X.dot(W) assert X_lda.shape == (150,2) 作图def plot_step_lda(): ax = plt.subplot(111) for label,marker,color in zip( range(1,4),(&#39;^&#39;, &#39;s&#39;, &#39;o&#39;),(&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;)): plt.scatter(x=X_lda[:,0].real[y == label], y=X_lda[:,1].real[y == label], marker=marker, color=color, alpha=0.5, label=label_dict[label] ) plt.xlabel(&#39;LD1&#39;) plt.ylabel(&#39;LD2&#39;) leg = plt.legend(loc=&#39;upper right&#39;, fancybox=True) leg.get_frame().set_alpha(0.5) plt.title(&#39;LDA: Iris projection onto the first 2 linear discriminants&#39;) # hide axis ticks plt.tick_params(axis=&quot;both&quot;, which=&quot;both&quot;, bottom=&quot;off&quot;, top=&quot;off&quot;, labelbottom=&quot;on&quot;, left=&quot;off&quot;, right=&quot;off&quot;, labelleft=&quot;on&quot;) # remove axis spines ax.spines[&quot;top&quot;].set_visible(False) ax.spines[&quot;right&quot;].set_visible(False) ax.spines[&quot;bottom&quot;].set_visible(False) ax.spines[&quot;left&quot;].set_visible(False) plt.grid() plt.tight_layout plt.savefig(&quot;LDA.png&quot;) plot_step_lda() Reference推荐看老外的英文介绍老外的翻译版机器学习-线性判别分析.周志华xLAC拉格朗日乘子法PAC二分类LAD","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"实验进展","slug":"实验进展","date":"2019-03-08T03:05:44.000Z","updated":"2019-03-10T16:09:28.263Z","comments":true,"path":"archives/e5775d07.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/e5775d07.html","excerpt":"","text":"2019-03-10各个组织间表达模式分析基于前面的4中分类，我又分别对每一类进行了更细致的划分 相同亚基因组(A2 At Vs D5 Dt)在进化上角度上的比较 研究从祖先到后代的传递过程中，相对于祖先的状态是否发生了改变；这种改变在At和Dt的情况又是否一样呢 第一类中分为了不同的两类 第二类也分为了不同的两类 以此类推….. 不同亚基因组(A2 D5 Vs At Dt)在进化上角度上的比较 在祖先中原来两个分散的亚基因组，随着多倍化的事件在后代中聚合在一起,当At与Dt位于同一个细胞核内，是否对其各自的转录调控是否存在一定的影响呢 纤维发育的两个时期的表达模式 分别比较10DPA的fiber与20DPA的fiber在第一类(class1)和第二类(calss2)中表达的一致性 相同亚基因组的比较A2 At Vs D5 Dt class1class22. 不同亚基因组的比较A2 D5 Vs At Dtclass1class23. 对各个组织间表达一致的基因数目进行了统计- 相同亚基因组之间的比较 A2-At Vs D5-Dtcategoryleaf和fiber各个时期的ovuleleaf和petalcalss1class1_1306082class1_2524647calss2class2_192820class2_2132528class3class3_1160310348class3_2111161206class3_345115193class3_4110150246calss4375250408075- 不同亚基因组的比较 A2-D5 Vs At-Dtcategoryleaf和fiber各个时期的ovuleleaf和petalcalss1class1_166134117class1_2101138122calss2class2_1102525class2_2172425class3class3_1157218262class3_2106269189class3_3104250223class3_4206535312calss4431155887863 总结 维恩图只做了10DPA和20DPA的fiber的交集，因为佳琦的有fiber和leaf的DHS数据，我想同时对这三个组织进行分析，于是我对这三个组织也取了交集看一下，从上面两个表中也可以看到；再加上leaf组织取交集之后，表达一致的基因数目比维恩图中的数目少了不少 从这两个表来看，第二类在两个亚组间在多个组织都呈现相反的表达情况，似乎很少见这与我之前看到的文章差不多 2019-03-01分别对每一类在各个组织中的基因数目进行统计 关于各个组织间对应基因数目的统计 A2-D5 vs At-Dt 一共有18,689对亚基因组同源基因pairs，下图是各个组织中每种分类的基因对的数目 A2-At vs D5-Dt 对10天纤维和20天的纤维中的基因表达模式一致和不一致的进行了统计 其中每种颜色的link对应的一种表达模式，而灰色的则是表达模式在两个时期发生了改变 category 10fiber 20fiber Consistent calss1 1849 1572 772 calss2 996 965 330 class3 8224 8087 4864 class4 7620 8065 5368 Total 18,689 18,689 113,34 2019-02-27基因表达模式分类 在亚基因组同源基因表达模式分析中从两个角度进行分析 祖先到后代过程中，同一个基因组发生的变化例如 A2-At vs D5-Dt 祖先到后代过程中，亚基因组之间的变化 A2-D5 vs At-Dt 基于以上思想分别从这两个角度对这四个基因组的同源基因的表达模式进行分类分类的模式如下 category A2-At Vs D5-Dt A2-D5 Vs At-Dt calss1 At&gt;A2 vs Dt&gt;D5 At&lt;A2 vs Dt&lt;D5 A2&gt;D5 vs At&gt;Dt A2&lt;D5 vs At&lt;Dt class2 Dt&gt;D5 vs At&lt;A2 At&gt;A2 vs Dt&lt;D5 A2&gt;D5 vs At&lt;Dt At&gt;Dt vs A2&lt;D5 class3 At!=A2 vs Dt=D5 At=A2 vs Dt!=D5 A2=D5 vs At!=Dt A2!=D5 vs At=Dt class4 At=A2 Dt=D5 A2=D5 At=Dt 任选其中的一个角度去解释这种分类的意义 class1中At大于A2 Dt&gt;D5与祖先相比At Dt两个基因组是相同的变化calss2中At大于A2 Dt小于D5 At与Dt在于祖先的比较中是相反的变化class3中At或Dt中的一个基因组与祖先相比没有变化calss4中At与Dt与祖先相比都没有变化 对于A2 D5 Vs At Dt 同样可以做这种解释 作图基于这种分类，画出在各个组织中对应的差异倍数的均值 从A2 D5 Vs At Dt 的角度作图 从A2 At Vs D5 Dt 的角度作图也是同样的 图中颜色相同的线表示的是同一种亚基因组同源基因 图1中两条红色线，和旁边的图例分别表示 在Ancestor中A2&gt;D5;在posterity后代中At&gt;Dt 通过性状区分Ancestor与posterity，而颜色相同表示它们是同一组亚基因组同源基因对A2-D5-At-Dt 参考维恩图2维恩图2维恩图3","categories":[],"tags":[]},{"title":"梯度上升算法实现","slug":"梯度上升算法实现","date":"2019-03-07T07:43:06.000Z","updated":"2019-03-07T08:12:32.188Z","comments":true,"path":"archives/1df1d0ad.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/1df1d0ad.html","excerpt":"","text":"梯度上升算法概念例如我们存在一个函数 f(x)=X2+4x要求它的极值，主要就是求偏导为0的那个点的坐标像这种简单的函数直接使f(x)‘为0就行 但在真实的情况中函数没有我们想象的这么简单，那就只能让我们一步一步的逼近极值点 X i+1=X i+a*f(x)‘ a为步长控制更新的幅度，当函数值无限逼近极值点时停止迭代过程 代码实现#coding=UTF-8 &#39;&#39;&#39; 梯度上升算法的简单实现 原函数 f(x)=x2+4x &#39;&#39;&#39; def Gradient(): ##定义导函数 def gradientPrim(X): return -2*X+4 x_old=1 x_new=0 ###控制步长度 alpha=0.01 #####控制梯度阈值 presision=0.0000001 while abs(x_new-x_old)&gt;presision: x_old=x_new #将提升后的值代入导函数求得新的坐标点； #当导函数无限的笔记0的时候，x_old与x_new也就无限逼近了 x_new=x_old+alpha*gradientPrim(x_old) print(x_new) Gradient() 总结 梯度上升与梯度下降算法主要的一个思想 当函数达到极值点时，导函数为0,这时新的坐标点与旧的坐标点之间的距离将无限的逼近 逼近的精度受到判断指标presision影响 同时步长主要影响的是迭代的次数 参考https://blog.csdn.net/c406495762/article/details/77723333","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"logistic回归","slug":"logistic回归","date":"2019-03-07T06:38:42.000Z","updated":"2019-03-09T14:54:56.988Z","comments":true,"path":"archives/b10b3e49.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/b10b3e49.html","excerpt":"","text":"概念 logistics回归是一种二分类的算法，它利用sigmoid函数将样本数据映射在[0,1]空间 假设我们的一个样本有n个属性x 1…x n,那就需要有n个参数构成的矩阵，将其构造成一个线性模型 对每一个样本我们都可以使用这个参数矩阵去计算一个条件概率； P(y=1|x,w)=0.51P(y=1|x,w)=0.99同一个样本在不同的参数矩阵w下，对样本估计为1的概率不同，我们需要取得最大的概率 扩展到整个样本， 又因为样本之间是独立同分布的，就可以用每个样本的概率做累乘 做完乘法之后将会得到一个关于w矩阵的概率函数，我们训练的目的就是要寻找一组w参数来使得我们正确判断y=1与y=0的概率达到最大 关于累乘的求导，通常使用ln函数变成累加，方便计算 这就回到了对函数求极值点的问题了，数据已经有了接下来就是要梯度法进行求解就行 在梯度下降过程中使用矢量法进行替换求解公式推导 矢量化在利用梯度求解过程中使用到矢量化的思想 在迭代的过程中设置w参数的初始值为 n x 1 的矩阵 接下来往公式里套就行了代码实现 #ocding=UTF-8 ### #罗杰斯特回归 ## import numpy as np ##读取文件数据 # # def loadDataSet(): dataMat=[] labelMat=[] fr=open(&quot;testSet.txt&quot;) for line in fr.readlines(): linerArr=line.strip().split() dataMat.append([1,float(linerArr[0]),float(linerArr[1])]) labelMat.append(int(linerArr[2])) fr.close() return(dataMat,labelMat) def sigmoid(x): return(1.0/(1+np.exp(-x))) ####梯度上升法#### def gradAscent(dataMatin,labelMatin): dataMatout=np.mat(dataMatin) labelMatout=np.mat(labelMatin).transpose() m,n=np.shape(dataMatout) alpha=0.001 maxCycle=500 ###初始参数的矩阵 weights=np.ones((n,1)) for k in range(maxCycle): ##这里已经把累加算了，得到m x 1矩阵 h=sigmoid(dataMatout*weights) error=labelMatout-h #####把x矩阵转置构造 n x m 矩阵 weights=weights+alpha*dataMatout.transpose()*error return weights dataMat,labelMat=loadDataSet() print(gradAscent(dataMat,labelMat)) 参考https://blog.csdn.net/lgb_love/article/details/80592147https://blog.csdn.net/c406495762/article/details/77723333最大似然法矢量化","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"高斯消元法","slug":"高斯消元法","date":"2019-03-07T05:49:01.000Z","updated":"2019-03-09T15:06:05.314Z","comments":true,"path":"archives/eccd8894.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/eccd8894.html","excerpt":"","text":"高斯消元法介绍 高斯消元法主要用在解线性方程，当前实现的仅仅是有唯一解的一个算法 x1 x2 x3 val 1 2 3 5 3 4 4 7 3 4 5 6 将线性方程变成一个上三角矩阵的过程1 2 3 3 40 1 2 3 40 0 1 2 30 0 0 3 3 从这个矩阵也不难看出是一个n x (n+1)类型 实现步骤 实现上三角转换主要是进行遍历，遍历的过程主要就是让每行的参数变为0 第一行遍历剩下的n-1行第二行遍历剩下的n-2行 所有行都遍历 上三角转换后，计算参数这里可以利用 n x (n+1)这一特性 源代码#coding=UTF-8 ###高斯消元法实现######### def Gauss(data): ##i是列元素j是控制循环的次数，line是存储一行元素 i=0 j=0 line_size=len(data) while j&lt;line_size-1: ###得到数据中的行 line=data[j] temp=data[j][j] templete=[] for x in line: x=x/temp templete.append(x) data[j]=templete flag=j+1 ######遍历第1行以后的行 while flag&lt;line_size: templete1=[] temp1=data[flag][j] i=0 ####将行的每一个元素与第一行相减 for x1 in data[flag]: if x1 !=0: x1=x1-(temp1*templete[i]) templete1.append(x1) else: templete1.append(0) i+=1 data[flag]=templete1 flag+=1 ##第一个参数已经消去，遍历消去剩下的参数 j+=1 #################对得到的上三角矩阵计算参数########### &#39;&#39;&#39; [1,2,3,4,5 0,2,3,4,5 0,0,4,5,6 0,0,0,1,3 ] &#39;&#39;&#39; parameter=[] parameter.append(data[line_size-1][-1]/data[line_size-1][-2]) ##parameter的下标刚好是所有参数剪切 #####从倒数第二列开始计算参数# i=line_size-2 while i &gt;=0: sum=0 parameter1=0 #这里分别进行回带，通过paramete数组 for j in range(i+1,line_size): sum+=parameter[line_size-1-j]*data[i][j] parameter1=(data[i][-1]-sum)/data[i][i] parameter.append(parameter1) i=i-1 return(parameter) #####进行消元测试####### parameters=[ [6,15, 55,152.6], [15, 55, 225, 585.6], [55,225,979,2488.8] ] results=Gauss(parameters) print(&quot;x1=&quot;+str(results[-1])+&quot;\\nx2=&quot;+str(results[-2])+&quot;\\nx3=&quot;+str(results[0])+&quot;\\n&quot;) 总结其实思想很简单，代码实现的时候有一些小技巧 关于python画图的画等有时间再进行摸索吧 参考 https://blog.csdn.net/deramer1/article/details/79049625","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"最小二乘python实现","slug":"最小二乘python实现","date":"2019-03-06T14:26:52.000Z","updated":"2019-03-09T14:58:29.821Z","comments":true,"path":"archives/6c33c6ae.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/6c33c6ae.html","excerpt":"","text":"什么是最小二乘法通常用来对改定数据集D做线性回归，找到一条最逼近整个数据集的直线；在这里我只使用了一个属性到y的映射，其实也有多个属性可以同时进行映射，就需要用到降维的思想，例如我们有一对刮南瓜、西瓜、黄瓜；既可以使用三个坐标系将它们进行刻画。 让拟合直线上的每一个点距离D中的点的离均差的误差最小 Σ1m(f(xi)-yi)2 推理步骤 当所有样本到直线上的点最小时，相当于对K和b求偏导为0 分别对k和b的公式进行转换，得到k和b的值 我发现它必定要过（x,y）的平均值的那个点 python实现#coding=UTF-8 &#39;&#39;&#39; 进行一元数据的拟合 &#39;&#39;&#39; x=[1,2,3,4,5,6,7] y=[3,4,5,6,7,8,9] ###计算拟合参数###### def lineFitting(data_x,data_y): ###获取集合中样本数目 size=len(data_x) ##构造遍历索引变量 i=0 ###声明公式中的变量 sum_x=0 sum_y=0 sum_Xsquare=0 sum_xy=0 average_x=0 average_y=0 ######对各个变量进行赋值 while i&lt;size: sum_x+=data_x[i] sum_y+=data_y[i] sum_Xsquare+=data_x[i]*data_x[i] sum_xy+=data_x[i]*data_y[i] i+=1 average_x=sum_x/size average_y=sum_y/size ###获取各个参数后直接套公式#### k=(sum_xy-sum_y*average_x)/(sum_Xsquare-sum_x*average_x) b=average_y-k*average_x return [k,b] #########计算拟合后的参数######### fittingParameter=lineFitting(x,y) print(&quot;y=&quot;+str(fittingParameter[0])+&quot;*x&quot;+&quot;+&quot;+str(fittingParameter[1])+&quot;\\n&quot;) 绘图最后本来打算画一个图的，但是在服务器上跑脚本，图片就算了吧","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"【持续更新】关于hexo博客的搭建","slug":"关于hexo博客的搭建","date":"2019-03-05T10:06:07.000Z","updated":"2019-03-12T01:23:24.466Z","comments":true,"path":"archives/d86fd5e9.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/d86fd5e9.html","excerpt":"","text":"Quick start关于如何进行安装hexo和一些配置插件的过程我这里就不详细介绍了；大家可以百度网上一大堆，当然我这里推荐一些讲的比较好的博客遇见西门里面介绍了如何进行hexo的安装与主题的优化 插件的配置我使用的是gitment，还是对github比较有好感，具体教程参考：gitment 永久链接的配置借助于hexo-abbrlink插件，安装好之后呢；在博客目录下的配置文件中修改_config.yml文件就ok，具体的修改方式如下 permalink: archives/:abbrlink.html abbrlink: alg: crc32 rep: hex 参考 关于在github二级仓库中构建博客 首先是在博客目录下的配置文件中进行设置url: https://zpliu1126.github.io/hexoTest root: /hexoTest/ 接着就是关于搜素插件如何找到对应文件路径设置/*#######设置数据库所在文件*/ xhr.open(&#39;GET&#39;, &#39;/hexoTest/content.json&#39;, true); 由于该主题作者 Snippet并没有考虑到这一情况，我是在获取conten.js的路径中进行了修改 对应找到对应的数据文件之后进行路径的构造/*关于在搜素结果content.json获取数据后加上子repository名构造最后url*/ path: &quot;hexoTest/&quot;+post.path, 其实就是一个字符串拼接的过程 关于文章如何进行分类的问题 1.在theme配置文件中打开category和tag标签 2.接着在每一个生成的文章中需要定义好category和tag内容才能进行跳转 3.同时在theme配置文件中可以定义好一些目录的跳转链接 #########文章的开头########## --- title: 关于hexo博客的搭建 abbrlink: d86fd5e9 date: 2019-03-05 18:06:07 category: computerLanguage tag: - JavaScript - html - css --- ######导航栏########## menu: - page: home url: /hexoTest icon: - page: 计算机程序 url: /hexoTest/categories/computerLanguage/ icon: - page: Bioinformatic url: /hexoTest/categories/Bioinformatic/ 添加背景音乐 首先在网页版网易云找到喜欢的音乐，点击添加外部播放器有html和flash版本 我选择html版本，然后在theme的部署文件里随便找了个地方放了进去 最后调整播放框的大小 文章加密访问 基于插件访问 hexo-blog-encrypt 修改根目录配置文件 Security encrypt: enable: true 在文章头部加上password字段图片放大的插件 首先得依赖于jauery1.11.1版本，我试的1.13.1版本不合适 关于图片的触发，在img标签中加上class=pimg 最后是触发后的位置需要进行承载承载我写了一个div class=Bigimglocation标签进行承载 在触发的js中加入$(.Bigimglocation).load(“承载的html”) 最后只需加上在img标签中class=pimg 并加上承载类&lt;img class=&quot;pimg&quot; src=&quot;&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;Bigimglocation&quot;&gt;&lt;/div&gt; 代码高亮 首先在head标签内引入css和js代码 在copyright区域触发 这里在我的主题下还存在一些行号冲突的问题，于是我干脆就直接把主题自带的css文件定义好的行号标签修改 display: none;修改后的高亮，看起来舒服多了 唯一的缺点就是代码的高亮可能会存在一定的延迟&lt;script type=&quot;text/javascript&quot;&gt; // Say hello world until the user starts questioning // the meaningfulness of their existence. function helloWorld(world) { for (var i = 42; --i &gt;= 0;) { alert(&#39;Hello &#39; + String(world)); } } &lt;/script&gt; &lt;style&gt; p { color: pink } b { color: blue } u { color: &quot;umber&quot; } &lt;/style&gt; 我部署到网站之后与本地的效果还是有一些出入 稍作修改，对 margin:0;参数改一下就行了;同时将要写代码的地方空一行，不这样有可能发生错误 将网站推送到搜素引擎SEO 由于百度爬虫太疯狂，影响了github的用户体验，因此百度爬虫被github封了基于这种考虑，我将github推送到Google SEO同时在codingme 也建了一个类似的站，就让百度爬取codingme上的内容；内容同时发布在两个网站上 百度SEO提交Google SEO提交博客根目录配置信息 deploy: type: git repo: github: git@github.com:zpliu1126/Blog.git,gh-pages coding: git@git.dev.tencent.com:zpliu1126/Blog.git,master 参考文章加密图片放大代码高亮代码漂亮的主题代码配色SEO推送","categories":[{"name":"computerLanguage","slug":"computerLanguage","permalink":"https://zpliu1126.github.io/Blog/categories/computerLanguage/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zpliu1126.github.io/Blog/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://zpliu1126.github.io/Blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://zpliu1126.github.io/Blog/tags/css/"}]},{"title":"本地Blast教程","slug":"本地Blast教程","date":"2019-03-05T10:04:50.000Z","updated":"2019-03-06T01:30:49.638Z","comments":true,"path":"archives/d57c3785.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/d57c3785.html","excerpt":"","text":"blast+安装 通过wget 命令直接下载到本地服务器中wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/ncbi-blast-2.2.30+-x64-linux.tar.gz 对下载好的文件进行解压tar -zxvf ncbi-blast-2.2.30+-x64-linux.tar.gz 解压之后，其实就可以使用绝对路径使用blast+了；怎么知道blast的绝对路径呢pwd ncbi-blast-2.2.30+-x64-linux.tar.gz/bin ######例如我们得到这样的绝对路径########## /home/local/software/ncbi-blast-2.2.30+-x64-linux/bin/ 这条命令就得到了我们blast可执行程序所在的绝对路径，也就是在电脑上的哪个文件夹 有了绝对路径我们就可以告诉计算机到哪里去找balst程序来执行当执行blastn核苷酸比对程序时直接使用下面的命令就可以执行了/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin/blastn 添加可执行程序到环境变量中 首先环境变量是啥？环境变量其实就是一个变量，这个变量里面包括一个叫$PATH的变量，里面存储着一些你想告诉计算机的东西。比如我想告诉计算机blast+的所有可执行的程序都放在哪个文件里面，我只需要在$PATH这个变量中加上blast/bin的文件夹；这样当我们在计算机的任何地方想要执行balst的时候只需要按下blastn或者其他命令就行了echo &quot;export PATH=/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin:\\$PATH&quot; &gt;&gt; ~/.bashrc source ~/.bashrc blast的使用构建本地blast库例如要构建核酸库，使用整个CDS构建的基因序列库makeblastdb -in &quot;CDS文件&quot; -dbtype &quot;nucl&quot; -parse_seqids -out &quot;库名称的前缀&quot; 具体参数的意义可以使用 -help参数查看手册，我就不多做赘述同理构建蛋白库makeblastdb -in &quot;氨基酸序列文件&quot; -dbtype &quot;prot&quot; -parse_seqids -out &quot;库名称的前缀&quot; 进行序列比对 首先我们需要准备比对的fasta文件，然后一条命令就可以了blastn -query &quot;需要比对的文件&quot; -db &quot;上一步建好的库的目录加上/库前缀&quot; -evalue 1e-5 -outfmt 6 -out &quot;输出文件&quot; 这里的outfmt是输出文件的格式，包括1-10种格式 具体参数的意义，可以使用–help参数查看","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[{"name":"Blast","slug":"Blast","permalink":"https://zpliu1126.github.io/Blog/tags/Blast/"}]},{"title":"模型评估与选择","slug":"模型评估与选择","date":"2019-03-05T09:49:35.000Z","updated":"2019-03-05T09:52:03.231Z","comments":true,"path":"archives/7d1dcda7.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/7d1dcda7.html","excerpt":"","text":"","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://zpliu1126.github.io/Blog/tags/基础/"}]},{"title":"Linux基础篇","slug":"Linux","date":"2019-03-05T09:46:11.000Z","updated":"2019-03-05T09:53:14.859Z","comments":true,"path":"archives/53d0684b.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/53d0684b.html","excerpt":"","text":"","categories":[{"name":"computerLanguage","slug":"computerLanguage","permalink":"https://zpliu1126.github.io/Blog/categories/computerLanguage/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zpliu1126.github.io/Blog/tags/Linux/"}]},{"title":"Circos其实很简单","slug":"Circos其实很简单","date":"2019-03-05T09:40:46.000Z","updated":"2019-03-14T07:18:30.181Z","comments":true,"path":"archives/87ef918.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/87ef918.html","excerpt":"","text":"颜色设置 在colors标签内自定义颜色 ##在mycolors.conf中定义 Atcolor=25,181,254 Acolor=0,230,64 Dtcolor=240,255,0 Dcolor=242,38,19 ## 在主文件circos.conf的colors标签内引用 &lt;colors&gt; &lt;&lt;include mycolors.conf&gt;&gt; &lt;/colors&gt; 自定义的颜色就可以使用了，例如我使用自定义颜色修饰染色体 chr - At02 At02 0 108049532 Atcolor chr - Dt13 Dt13 0 63316526 Dtcolor chr - A02 A02 0 99090824 Acolor chr - D12 D12 0 35429946 Dcolor 在circos.conf中使用rgb()函数自定义颜色， &lt;link&gt; file=data/At_AC.txt radius=0.95r bezider_radius=1.5r thickness=3 color=rgb(140,20,252) z=20 &lt;/link&gt; links中rule规则 让color颜色与第二个连接点的颜色相同 color=eval(var(chr2)) # eval函数与大多数语言中的功能类似，在bash中eval会执行字符串表示的命令 link有时候会缠绕在一块就像下面这样这时候只需要把对应的染色体翻转一下就行啦！ chromosomes_reverse=At13;D04;D11;D10;D09;A07;A05;A08; ###两条线交叉的时候可以考虑把染色体顺序换一下 chromosomes_order=At01,At02,At03,At04,At05,At06, link中的rule规则 取从哪条染色体开始 &lt;rule&gt; condition=from(Chr03) color=rgb(247,202,24) &lt;/rule&gt; 添加注释信息例如在染色体对应的位置添加对应的基因编号信息,首先得准备对应的数据文件text.txt A02 38395050 38401512 Ga02G0753.1 A05 916845 922879 Ga05G0093.1 A05 929480 933564 Ga05G0095.1 A05 977266 983344 Ga05G0100.1 A05 14673170 14690147 Ga05G1638.1 A06 56575979 56582045 Ga06G1315.1 在circos.conf中的plots标签内定义type=text &lt;plots&gt; type=text r0=1.05r r1=1.1r+400p show_links=yes link_dims=4p,4p,8p,4p,4p link_thickness=2p label_size=24p color=red label_font=condensed padding=0p rpadding=0p &lt;plot&gt; file=data/textAt.txt color=rgb(25,181,254) &lt;/plot&gt; &lt;/plots&gt; 具体参数的意义: histogram柱状图 数据文件格式如下：染色体位置+柱状图的大小 CA_chr1 109361328 109659167 9 CA_chr1 137401104 137443513 8 CA_chr1 134830783 135785508 48 CA_chr1 135908705 136353163 24 CA_chr1 61257167 61388884 8 CA_chr1 56197340 56261821 6 CA_chr1 117275800 117755122 12 CA_chr1 123325601 123882451 8 CA_chr1 58923028 59194595 8 CA_chr1 47239752 47399584 7 CA_chr1 66213515 67537745 49 有时候为了让边框没有颜色，可以考虑把thickness设置为0 &lt;plots&gt; r0=0.9r r1=0.97r color=red thickness=0 &lt;plot&gt; type=histogram file=data/Ahighlight.txt fill_color=rgb(255,203,5) &lt;/plot&gt;","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[{"name":"Circos学习","slug":"Circos学习","permalink":"https://zpliu1126.github.io/Blog/tags/Circos学习/"}]}]}