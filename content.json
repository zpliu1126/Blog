{"meta":{"title":"ZpliuBlog","subtitle":null,"description":null,"author":"zpliu","url":"https://zpliu1126.github.io/Blog","root":"/Blog/"},"pages":[{"title":"Music","date":"2019-03-09T11:16:49.000Z","updated":"2019-03-09T11:29:14.236Z","comments":true,"path":"Music/index.html","permalink":"https://zpliu1126.github.io/Blog/Music/index.html","excerpt":"","text":"Music L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/Blog/live2dw/assets/z16.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":false}});"},{"title":"categories","date":"2019-03-05T09:43:46.000Z","updated":"2019-03-05T09:43:46.211Z","comments":true,"path":"categories/index.html","permalink":"https://zpliu1126.github.io/Blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-03T05:34:48.000Z","updated":"2019-03-05T04:24:33.442Z","comments":true,"path":"tags/index.html","permalink":"https://zpliu1126.github.io/Blog/tags/index.html","excerpt":"","text":""},{"title":"js","date":"2019-03-16T02:55:44.000Z","updated":"2019-03-21T08:47:02.709Z","comments":true,"path":"js/index.html","permalink":"https://zpliu1126.github.io/Blog/js/index.html","excerpt":"","text":"button var a=[1,2,3,45,5,2] function remove(arry,item){ for(i=0;i"}],"posts":[{"title":"wordpres安装","slug":"wordpres安装","date":"2019-03-24T03:13:30.000Z","updated":"2019-05-19T01:51:27.688Z","comments":true,"path":"archives/94b7d4b0.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/94b7d4b0.html","excerpt":"","text":"问候信息/inc/user/unser-profile.php &lt;script type=&quot;text/javascript&quot;&gt; today = new Date(); var day; var date; var hello; hour = new Date().getHours(); if (hour &lt; 6) { hello = &#39; 凌晨好！ &#39;; } else if (hour &lt; 9) { hello = &#39; 早上好！&#39;; } else if (hour &lt; 12) { hello = &#39; 上午好！&#39;; } else if (hour &lt; 14) { hello = &#39; 中午好！ &#39;; } else if (hour &lt; 17) { hello = &#39; 下午好！ &#39;; } else if (hour &lt; 19) { hello = &#39; 傍晚好！&#39;; } else if (hour &lt; 22) { hello = &#39; 晚上好！ &#39;; } else { hello = &#39;夜深了！ &#39;; } function GetCookie(sName) { var arr = document.cookie.match(new RegExp(&quot;(^| )&quot; + sName + &quot;=([^;]*)(;|$)&quot;)); if (arr != null) { return unescape(arr[2]) }; return null; } var Guest_Name = decodeURIComponent(GetCookie(&#39;author&#39;)); var webUrl = webUrl; if (Guest_Name != &quot;null&quot;) { hello = Guest_Name + &#39; , &#39; + hello + &#39; 欢迎回来。&#39;; } document.write(&#39; &#39; + hello);&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;var d, s = &quot;&quot;; var x = new Array(&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;); d = new Date(); s += d.getFullYear() + &quot;年&quot; + (d.getMonth() + 1) + &quot;月&quot; + d.getDate() + &quot;日 &quot;; s += x[d.getDay()]; document.writeln(s);&lt;/script&gt; 文章永久链接apache支持htaccess文件，修改httpd配置文件 &#39;&#39;&#39;修改AllowOverride 参数&#39;&#39;&#39; &lt;Directory &quot;/var/www/html&quot;&gt; AllowOverride All &lt;/Directory&gt; &#39;&#39;&#39;加载模块&#39;&#39;&#39; #wordpress 404 model LoadModule rewrite_module modules/mod_rewrite.so 图片文字环绕修改style.css 中对应的类，添加float属性 .logo-site img, .logo-sites img { width: 50px; max-height: 50px; float: left; } 接着修改模板文件中的menu.php文件修改描述 if ( is_front_page() || is_category() || is_home() ) : ?&gt; &lt;?php if (zm_get_option(&#39;logos&#39;)) { ?&gt; &lt;?php if ( zm_get_option(&#39;logo&#39;) ) { ?&gt; &lt;a href=&quot;&lt;?php echo esc_url( home_url(&#39;/&#39;) ); ?&gt;&quot;&gt;&lt;img src=&quot;&lt;?php echo zm_get_option(&#39;logo&#39;); ?&gt;&quot; title=&quot;&lt;?php echo esc_attr( get_bloginfo( &#39;name&#39;, &#39;display&#39; ) ); ?&gt;&quot; alt=&quot;&lt;?php bloginfo( &#39;name&#39; ); ?&gt;&quot; rel=&quot;home&quot; /&gt;&lt;/a&gt; &lt;?php } ?&gt; &lt;a href=&quot;&lt;?php echo esc_url( home_url(&#39;/&#39;) ); ?&gt;&quot;&gt;&lt;h1 class=&quot;site-title&quot;&gt;&lt;?php bloginfo( &#39;name&#39; ); ?&gt; &lt;/h1&gt; &lt;p class=&quot;site-description&quot;&gt;Good Ideal Power Excution&lt;!-- &lt;?php bloginfo( &#39;description&#39; ); ?&gt; --&gt;&lt;/p&gt;&lt;/a&gt; &lt;? php } ?&gt; 修改关于本站的居中选项/* 关于本站*/ .about-img { text-align: center; background: url(http://www.zpliublog.club/wp-content/uploads/2019/03/background-300x169.png) center center no-repeat; background-size: cover; height: 120px; margin: 0px 0 40px 0; } .about-img img { width: 120px; height: auto; margin: 35px 0px 0 0; padding: 2px; border-radius: 50%; border: 2px solid #f8f8f8; text-align: center; } .about-name { font-size: 16px; font-weight: 700; text-align: center; } 文章特色图片http://zmingcx.com/automatically-adds-the-characteristic-images.html https://liuyanzhao.com/4507.html 美话标签云注册后页面跳转https://www.ludou.org/wordpress-do-action-after-registration.html function auto_login_new_user( $user_id ) { // 用户注册后自动登录 wp_set_current_user($user_id); wp_set_auth_cookie($user_id); // 这里跳转到 http://域名/about 页面，请根据自己的需要修改 wp_redirect( home_url().&#39;/wp-login.php&#39; ); exit; } 邀请码问题没有得到解决 https://www.itbulu.com/easy-invitation-codes.html 配图http://www.sohu.com/a/206720121_473285 d代码高亮https://themeforwp.net/archives/best-code-highlight-plugin/ 人数统计https://www.luoyechenfei.com/html/2630.html 文章访问次数http://zmingcx.com/no-plugin-wordpress-reads.html 搭建SMTP邮件服务系统https://www.liwei8090.com/3172.html 评论回复通知在主题inc下的notify.php文件中已经存在这样的函数，注释掉就行了 http://www.kanbuchuan.com/?p=66 https://www.wpdaxue.com/comment-mail-notify.html 使用域名访问主题","categories":[],"tags":[]},{"title":"mysql数据库","slug":"mysql数据库","date":"2019-03-24T03:09:52.000Z","updated":"2019-03-29T12:03:39.977Z","comments":true,"path":"archives/82bdb349.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/82bdb349.html","excerpt":"","text":"phpmyadmin安装强大的mysql管理工具，支持自动补齐 下载到网站根目录后，直接配置文件就可以使用 cp config.sample.inc.php config.inc.php 显示数据库show databases; 对用户的操作 在mysql数据库中包含用户的信息 &gt;use mysql; &gt;select host,user from mysql.user; 创建用户 &gt;CREATE USER &#39;phpmywind&#39;@&#39;%&#39; identified by &#39;020311&#39; ; &#39;给用户赋予数据库权限&#39; &gt;grant all privileges on phpmywind_db.* to &#39;phpmywind&#39;@&#39;%&#39; ; 删除用户 &#39;只有root用户才有权限删除&#39; Delete FROM mysql.user Where User=&#39;user1&#39;; 对数据库的操作 创建数据库 &gt;create database phpmywind_db; 删除数据库 &gt;drop database phpmywind_db; 参考phpmyadmin安装","categories":[],"tags":[]},{"title":"ggplot2","slug":"ggplot2","date":"2019-03-23T08:40:36.000Z","updated":"2019-03-23T08:41:34.033Z","comments":true,"path":"archives/8ea15bec.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/8ea15bec.html","excerpt":"","text":"参考官方手册","categories":[],"tags":[]},{"title":"ggridges","slug":"ggridges","date":"2019-03-23T08:37:46.000Z","updated":"2019-03-23T08:40:20.223Z","comments":true,"path":"archives/b8fbfc3.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/b8fbfc3.html","excerpt":"","text":"参考官方手册","categories":[],"tags":[]},{"title":"tophat_cufflinks","slug":"tophat-cufflinks","date":"2019-03-22T04:33:54.000Z","updated":"2019-03-29T13:20:52.015Z","comments":true,"path":"archives/5ae3b518.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/5ae3b518.html","excerpt":"","text":"Hisat相当于Tophat的更新版本 主要参数 -x hisat-build 构建的索引文件 -U 单端测序的转录组数据文件 双端测序的转录组数据 -S 输出sam文件格式 –known-splicesite-infile 后面加注释文件，注释文件用自带的extract_splice_sites.py脚本将GTF文件转换一下 –rna-strandness 指定建库方式单端建库一般不用指定或者根据NCBI指定为F|R 双端建库使用FR|RF参数 建库方式参考:链特异性 -p 线程数目 TopHat has a similar option, –library-type option, where fr-firststrand corresponds to R and RF; fr-secondstrand corresponds to F and FR. hisat -x 索引文件前缀 -U|-1|-2 转录组数据 -S 输出sam文件 --known-splicesite-infile 注释文件 --rna-strandness 建库方式 -p 线程数 stringtiecufflinks的版本 主要参数-G 指导组装的注释文件，一般是GTF|GFF文件-e 与-G参数结合将不会组装新的转录本，仅仅根据注释文件进行计算-p 线程数目-A 指定输出注释文件中每个基因的丰度文件-o 包含完整的输出信息文件 stringtie 安装染色体位置排好序的bam文件 -G gtf注释文件 -e 与-G参数配合不组装新的转录本 -A 基因表达量输出文件 -o 完整的转录本信息文件 -p 线程数目 -v 脚本处理过程信息打印 Hisatstringtie链特异性Github of stringtie— abbrlink: ‘0’","categories":[],"tags":[]},{"title":"决策树","slug":"决策树","date":"2019-03-20T14:09:52.000Z","updated":"2019-03-21T05:35:42.746Z","comments":true,"path":"archives/8ddc7426.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/8ddc7426.html","excerpt":"","text":"基本概念决策树是一种基本的分类与回归，我们可以把决策树看成一个if-then规则；通过对数据集中属性进行判断，从而将数据打上对应的标签；这也是有监督学习的一种 流程 收集数据 整理数据，将数据按照一定的规则整理、排版 分析数据，构造决策树使用简单数据集，检查决策树是否符合预期 训练算法，使用你准备的数据集中的一部分数据，进行训练，构造出决策树数据结构 测试算法 使用算法 构造数据集def creatDataSet(): dataSet = [[0, 0, 0, 0, &#39;no&#39;], [0, 0, 0, 1, &#39;no&#39;], [0, 1, 0, 1, &#39;yes&#39;], [0, 1, 1, 0, &#39;yes&#39;], [0, 0, 0, 0, &#39;no&#39;], [1, 0, 0, 0, &#39;no&#39;], [1, 0, 0, 1, &#39;no&#39;], [1, 1, 1, 1, &#39;yes&#39;], [1, 0, 1, 2, &#39;yes&#39;], [1, 0, 1, 2, &#39;yes&#39;], [2, 0, 1, 2, &#39;yes&#39;], [2, 0, 1, 1, &#39;yes&#39;], [2, 1, 0, 1, &#39;yes&#39;], [2, 1, 0, 2, &#39;yes&#39;], [2, 0, 0, 0, &#39;no&#39;]] labels = [&#39;年龄&#39;, &#39;有工作&#39;, &#39;有自己的房子&#39;, &#39;信贷情况&#39;] return dataSet, labels 信息熵计算def calcShannonEnt(dataset): numEntires=len(dataset) #数据集的大小 labelCount={} #统计每一种分类对应的数目 for featVec in dataset: currentLabel=featVec[-1] #分类标签 if currentLabel not in labelCount: labelCount[currentLabel] = 0 labelCount[currentLabel]+=1 shannonEnt=0.0 for key in labelCount: prob=float(labelCount[key])/numEntires #计算权重使用float函数产生小数 shannonEnt-=prob*log(prob,2) return shannonEnt 寻找最优特征 遍历每一个属性 找到每一个属性对应值的子集D1、D2、D3 计算每个属性下的信息增益 找到当前数据集下，最优的分类属性 &#39;&#39;&#39; 找到对应的特征为value的行，将这个属性清除作为下一个子集D1 &#39;&#39;&#39; def splitDataSet(dataSet,axis,value): reDataSet=[] for featVec in dataSet: if featVec[axis]==value: reduceFeatVec=featVec[:axis] reduceFeatVec.extend(featVec[axis+1:]) reDataSet.append(reduceFeatVec) return reDataSet &#39;&#39;&#39; 找到当前数据集下，最优的分类属性 &#39;&#39;&#39; def chooseBestFeatureToSplit(dataset): numfeatures=len(dataset[0])-1 ##准备遍历每一个属性 baseEntropy=calcShannonEnt(dataset) ##初始信息熵 bestInfoGain=0.0 ##最大信息增益 bestFeature=-1 ##记录最优属性下标 for i in range(numfeatures): featList=[examp[i] for examp in dataset] #获得单个属性的所有值 uniqVals=set(featList) #去重，基于属性值分为子集D1、D2、D3 newEntrop=0.0 #每种属性对应的信息熵 for value in uniqVals: subsDataSet=splitDataSet(dataset,i,value) prob=len(subsDataSet)/float(len(dataset)) #子集占数据集权重 newEntrop+=prob*calcShannonEnt(subsDataSet) #将子集信息熵累加 inforGain=baseEntropy -newEntrop #信息增益 if(inforGain&gt;bestInfoGain): bestInfoGain=inforGain bestFeature=i #找到最优属性的下标 return bestFeature 构造决策树&#39;&#39;&#39; 当没有有意义的属性或者所有的属性都用完之后还没分开时，使用数目最多的那一类标签,作为这一类的标签 &#39;&#39;&#39; def majorityCnt(classList): classcount={} for vote in classList: if vote not in classcount.keys(): classcount[vote]=0 classcount[vote]+=1 sortclasscount=sorted(classcount.items(),key=operator.itemgetter(1),reverse=True) #对大小倒序输出 return sortclasscount[0][0] &#39;&#39;&#39; 构造决策树 &#39;&#39;&#39; def creatTree(dataset,labels,featLabels): #dataset初始数据集 labels属性名称 featLabels决策树找出的分类属性 classList=[example[-1] for example in dataset] #获取监督标签 if classList.count(classList[0])==len(classList): #当数据集中标签相同时，停止分类 return classList[0] if len(dataset[0])==1 or len(labels)==0: #没有可以分类的属性，或者属性都用完之后 return majorityCnt(classList) bestFeat=chooseBestFeatureToSplit(dataset) #获取最优属性 bestlabel=labels[bestFeat] ##最优属性的名字 featLabels.append(bestlabel) ##添加到输出结果中 myTree={bestlabel:{}} ##构造树形字典，键为最优属性名字，值为子树 del(labels[bestFeat]) #从属性名列表中删除，已经找到的 featValues=[example[bestFeat] for example in dataset] uniqueValues=set(featValues) for value in uniqueValues: myTree[bestlabel][value]=creatTree(splitDataSet(dataset,bestFeat,value),labels,featLabels) #从最优属性的子集D1、D2、D3中再分别得到第二优的属性... return myTree ############################### dataset,labels=creatDataSet() featLabels=[] myTree=creatTree(dataset,labels,featLabels) print(myTree) print(featLabels) 使用决策树参考https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.htmlhttps://cuijiahua.com/blog/2017/11/ml_3_decision_tree_2.html","categories":[],"tags":[]},{"title":"python矩阵操作","slug":"python矩阵操作","date":"2019-03-20T02:24:23.000Z","updated":"2019-03-20T02:42:13.881Z","comments":true,"path":"archives/776e0022.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/776e0022.html","excerpt":"","text":"矩阵转置使用np包或者numpy中的np包 import np #import numpy as np np.transpose(list) ##对矩阵转置 np.transpose([list]).tolist() ##返回列表 数组合并 水平合并，保持行数不变 np.hstack((a,b)) 垂直合并，保存列数不变 np.vstack((a,b)) 深度合并 np.dstack((a,b)) 列表拆分 获取某一行 a=[[1,2,3],[4,5,6]] a[0]=[1,2,3] 获取某一列 &gt;&gt;&gt;[x[0] for x in a] &gt;&gt;&gt;[1,4] ##数组直接使用下表就行 a=np.array(a) a[:,0] 参考转置数组合并列表拆分","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python MachineLearning","slug":"python-MachineLearning","permalink":"https://zpliu1126.github.io/Blog/tags/python-MachineLearning/"}]},{"title":"python命令行参数解析","slug":"python命令行参数解析","date":"2019-03-19T15:20:34.000Z","updated":"2019-03-20T10:59:44.732Z","comments":true,"path":"archives/35a77636.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/35a77636.html","excerpt":"","text":"getopt使用getopt与sys包对命令行参数进行解析，流程如下: 导入getopt与sys包 分析命令行参数 对传入结果进行变量化 分析命令行参数try: opts, args = getopt.getopt(sys.argv[1:], &quot;ho:&quot;, [&quot;help&quot;, &quot;output=&quot;]) except getopt.GetoptError: #print(&quot;error\\n&quot;) 在getopt函数中第一个参数对应着sys传入的值，第二个参数是解析的短参数，第三个则是对应的长参数：字母后面加冒号或等号，表示后面会有相应的sys参数 参数变量化opts是一个二元数组里面保存着参数和对应的值 [(‘-h’, ‘’), (‘-o’, ‘file’), (‘–help’, ‘’), (‘–output’, ‘out’)] if len(opts)==5: for name,value in opts: if name in (&quot;-h&quot;,&quot;--help&quot;): usage() sys.exit() if name in(&quot;-g&quot;,&quot;--gff&quot;): gfffile=value if name in(&quot;-s&quot;,&quot;--sgRNA&quot;): sgRNAfile=value if name in(&quot;-l&quot;,&quot;--genelength&quot;): genelength=int(value) if name in(&quot;-o&quot;,&quot;--outfile&quot;): outfile=value if name in(&quot;-r&quot;,&quot;--sequence&quot;): sgRNAsquencefile=value else: print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+&quot;Attention! lack parameters &quot;+&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;) usage() sys.exit() 利用参数变量解析到每个参数对应的sys值，后赋值给变量，之后就可以直接使用这个变量啦!同时使用了if进行判断，当没有输入参数时调用usage()和sys.exit() 进度条tqdm使用python中tqdm包来显示进度条，简单用法是传递可迭代对象给tqdm函数 tqdm函数接受一个迭代对象 一个描述行词语 ##对迭代列表进行操作 for i in tqdm(range(0,len(yourgenes)),desc=&quot;write file&quot;): yourgenes[i]=yourgenes[i].strip(&quot;\\n&quot;) out.write(&quot;&gt;&quot;+yourgenes[i]+&quot;\\n&quot;+genelist[yourgenes[i]]+&quot;\\n&quot;) 参考getopt1getopt2tqdm","categories":[{"name":"computerLanguage","slug":"computerLanguage","permalink":"https://zpliu1126.github.io/Blog/categories/computerLanguage/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"Circos基础","slug":"Circos基础","date":"2019-03-18T13:19:06.000Z","updated":"2019-03-18T13:49:00.892Z","comments":true,"path":"archives/c5b1c714.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/c5b1c714.html","excerpt":"","text":"quickly start 文件目录结构 首先circos中数据与代码相互分离，方便代码非管理；同时代码也可以实现重复利用 主要的配置写在circos.conf文件中，其他的配置文件是关于图片其他组件的配置；只需要在circos主配置文件中引入即可 circos在画图时首先从当前路径搜索配置文件，如果没有找到，会到circos软件包所在路径进行配置文件的搜索##相关配置文件etc/housekeeping.conf可以修改设定 CWD/ CWD/etc CWD/data CWD/../ CWD/../etc CWD/../data CWD/../.. CWD/../../etc CWD/../../data 有了配置文件接下来circos同样会在当前目录搜索对应的数据文件、配置文件；中如何引用其他文件如下 ##circos.conf引用其他配置文件 &lt;&lt;include etc/colors_fonts_patterns.conf&gt;&gt; &lt;&lt;include etc/housekeeping.conf&gt;&gt; ##circos.conf引用柱状图数据文件 &lt;plots&gt; &lt;plot&gt; type=histogram file=data/Dthighlight.txt fill_color=rgb(249,105,14) &lt;/plot&gt; &lt;/plots&gt;","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[{"name":"Circos学习","slug":"Circos学习","permalink":"https://zpliu1126.github.io/Blog/tags/Circos学习/"}]},{"title":"sgRNAcase9","slug":"sgRNAcase9","date":"2019-03-18T02:14:36.000Z","updated":"2019-05-19T01:08:32.498Z","comments":true,"path":"archives/4df5c5ce.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/4df5c5ce.html","excerpt":"","text":"靶标序列设计具体参数如下 -i &lt;str&gt; Input file -x &lt;int&gt; Length of sgRNA[20] -l &lt;int&gt; The minimum value of GC content [20] -m &lt;int&gt; The maximum value of GC content [80] -g &lt;str&gt; The reference genome sequence -o &lt;str&gt; Searching CRISPR target sites using DNA strands based option(s/a/b) [s, sense strand searching mode] [a, anti-sense strand searching mode] [b, both strand searching mode] -t &lt;str&gt; Type of sgRNA searching mode(s/p) [s, single-gRNA searching mode] [p, paired-gRNA searching mode] -v &lt;str&gt; Operation system(w/l/u/m/a) [w, for windows-32, 64] [l, for linux-64] [u, for linux-32] [m, for MacOSX-64] [a, for MacOSX-32] -n &lt;int&gt; Maximum number of mismatches [5] -s &lt;int&gt; The minimum value of sgRNA offset [-2] -e &lt;int&gt; The maximum value of sgRNA offset [32] -p &lt;str&gt; Output path 一般性的命令 perl sgRNAcas9_3.0.5.pl -i genes_end.fasta -x 20 -l 40 -m 60 -g Ghirsutum_genome.fasta -o b -t s -v l -n 5 -s -3 -e 33 -p /public/home/llpei/zpliu/zpliu/software/sgRNAcas9_3.0.5 2&gt;log.txt 提取对应等级的靶标ID Discard &gt; High_risk &gt; moderate_risk &gt; low_risk &gt; repeat_sites_or_bad ? &gt; Best一般提取Best 、repeat_sites_or_bad ? 、low_risk等级的ID 0M 1M 2M 3M rank 2 0 0 0 repeat_sites_or_bad 1 0 0 5 low_risk 1 0 0 3 Best 例如repeat等级中0M靶向的位置有2个，我们要看看它靶向的位置是否是同一个基因，进行sgRNA评价 靶标序列评价1.提取文件夹A.Sort_OT_byID中对应的0M 错配的碱基信息为0的进行评价 2.使用自带的脚本ot2gtf_v2.pl，对得到的sgRNA靶标进行评价，看这个靶标是否靶向对应的基因 这个脚本50行左右开始需要修改一下，默认是使用人类染色体编号进行的 #1 pseudogene gene 11869 14412 . + . gene_id &quot;ENSG00000223972&quot;; gene_name &quot;DDX11L1&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;pseudogene&quot;; (my $gtf_chr, my $gtf_annotation1, my $gtf_annotation2, my $gtf_beg, my $gtf_end, my $get_dot1, my $gtf_strand, my $gtf_dot2, my $gtf_annotation3)=split/\\t/, $_; # next unless $gtf_chr=~ /^[0-9]|^[X]|^[Y]/; next unless $gtf_chr eq $chr; # next if !$gtf_beg =~ /\\d+/; #gene_id &quot;ENSG00000223972&quot;; transcript_id &quot;ENST00000515242&quot;; gene_name &quot;DDX11L1&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;pseudogene&quot;; transcript_name &quot;DDX11L1-201&quot;; transcript_source &quot;ensembl&quot;; if ($gtf_annotation3=~ /&quot;.*gene_name &quot;([^&quot;]+)&quot;/) { $geneID = $1; #print $geneID,&quot;\\n&quot;; 去除脱靶的sgRNA从三个点出发 靶标基因与sgRNA的序列信息一致赋权值 0 sgRNA靶向同源基因和自己本身赋权值 0 靶标序列脱靶赋权值 1 最后将同一个sgRNA靶标的权值相加，为0则表示没有脱靶；否则脱靶舍弃 #awk脚本 -F &quot;\\t&quot; &#39;{ a=substr($1,1,15);a1=substr($1,6,1);a2=substr($1,7,2);b1=substr($5,6,1);b2=substr($5,7,2) }{ if(a==$8)print $0&quot;\\t&quot;0; else if(a1==&quot;A&quot;&amp;&amp;b1==&quot;D&quot;){ if(a2==b2||a2==&quot;02&quot;&amp;&amp;b2==03||a2==&quot;03&quot;&amp;&amp;b2==&quot;02&quot;){ print $0&quot;\\t&quot;0;}else print $0&quot;\\t&quot;1;} else if(a1==&quot;D&quot;&amp;&amp;b1==&quot;A&quot;){ if(a2==b2||a2==&quot;02&quot;&amp;&amp;b2==&quot;03&quot;||a2==&quot;03&quot;&amp;&amp;b2==&quot;02&quot;){ print $0&quot;\\t&quot;0;}else print $0&quot;\\t&quot;1;} else print $0&quot;\\t&quot;1;}&#39; Best_Repeat_Low_OT_gtf 得到我们所需的sgRNA靶标序列 对合格靶标序列进行筛选经过上一步筛选后的sgRNA文件，我们需要根据以下几个指标筛选比较理想的靶标序列 靶标序列尽量靠近5’端 同一个基因找两个靶标序列，尽量让这两段序列间隔在100bp左右 写了达到目的写了一个python脚本，脚本的使用如下 usage: -h|--help print help information -g|--gff= gff file path way -s|--sgRNA= sgRNA file path way -l|--genelength= length of gene -r|--sequence= sgRNA sequence path way -o|--outfile= output file path way 脚本获取 参考tiramisutessgRNAcase9","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[{"name":"CRISPR","slug":"CRISPR","permalink":"https://zpliu1126.github.io/Blog/tags/CRISPR/"}]},{"title":"js基础","slug":"js基础","date":"2019-03-16T03:04:28.000Z","updated":"2019-03-16T13:28:56.508Z","comments":true,"path":"archives/6890f50f.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/6890f50f.html","excerpt":"","text":"函数 this对象转换函数对象的apply()、call()方法与fun()调用效果是一样的，不同之处在于 使用fun()调用时，fun是windows的方法 而是用call与apply调用时，使用将fun方法赋给了对应的对象中 function fun(){ alert(this.name); } var obj1={name:&quot;obj1&quot;}; ###输出为空windows对象没有name属性 fun(); ###输出obj1 fun.call(obj1); fun.apply(obj1); 用call与apply将函数赋给对应的对象后，如果函数需要参数只需在后面加上对应的参数就行 apply中传递参数的时候需要数组进行传递call中不需要，直接单个单个传入 function fun(a,b){ alert(a+b); } var obj1={name:&quot;obj1&quot;,a:1,b:2}; fun(2,3); #######参数进行传递 fun.call(obj1,1,1); fun.apply(obj1,[5,6]); 函数参数arguments arguments是一种类数组结构，里面保留了传递给函数的实参 function fun(){ console.log(arguments.length); } fun(&quot;hello&quot;,&quot;2&quot;); ###打印为2 使用arguments对象中的实参我们也可以通过使用arguments[0]、arguments[1]等在函数中直接使用，而不使用形参；但这种方法比较麻烦 arguments的callee属性等于当前执行的函数对象 function fun(){ console.log(arguments.callee==fun ); } ###arguments的函数对象为fun返回true fun() Date构造函数 当新建一个Date对象的时候，打印的为创建Date对象的时间 #####Sat Mar 16 2019 11:44:23 GMT+0800 (中国标准时间)# ##创建对象时间 var d=new Date() console.log(d) 指定时间进行创建使用参数赋值给Date对象；格式为： 月份/日/年 空格 时:分:秒 Date的主要方法 实践一个时钟方法 function startTime(){ var now=new Date(); var hours=now.getHours(); var minute=now.getMinutes(); var second=now.getSeconds(); if(minute","categories":[{"name":"computerLanguage","slug":"computerLanguage","permalink":"https://zpliu1126.github.io/Blog/categories/computerLanguage/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zpliu1126.github.io/Blog/tags/JavaScript/"}]},{"title":"sed awk的奇技淫巧","slug":"Awk","date":"2019-03-15T01:32:18.000Z","updated":"2019-03-16T14:33:52.088Z","comments":true,"path":"archives/34076904.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/34076904.html","excerpt":"","text":"字符串 substr截取字符串长度 &gt;&gt;echo aaabbbcc |awk &#39;{print substr($1,2)}&#39; &gt;&gt;aabbbcc 第一个参数 截取的字段第二个截取的起始位置，默认下标从1开始第三个参数是指定截取的长度 gsub替换字符串 ###不使用正则 &gt;&gt;echo aaabbbcc |awk &#39;gsub(&quot;a&quot;,&quot;e&quot;,$1){print}&#39; &gt;&gt;eeebbbcc ###使用正则 &gt;&gt;echo aaabbbcc |awk &#39;gsub(/aa/,&quot;e&quot;,$1){print}&#39; &gt;&gt;eabbbcc 这与sed ‘s///g’的手法大同小异默认全局替换，也就是整个字段进行替换 统计 对出现的行的数目进行统计使用awk中的关联数组 &gt;&gt;awk &#39;{a[$1]+=1}END{for(i in a)print a[i];}&#39; 从代码中我们也可以看出使用关联数组来统计某一字段出现的次数； 延伸一下，我们通常需要找两个文件共同的基因，我通常的做法是使用 sort 加uniq -d 这样可以快速的找打两个文件中重复基因；但有多个文件的时候怎么办呢？这时候就可以考虑使用awk关联数组的办法了，使用cat合并文件之后统计基因出现的次数等于文件数目，也就找出来多个文件中共有的基因啦! awk -F “\\t” ‘{a=substr($1,1,15);b=substr($1,6,3);c=substr($8,6,3)}{if(a==$8){print $0”\\t”0;}else if()}’ Best_Repeat_Low_OT_gtf|less","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zpliu1126.github.io/Blog/categories/Linux/"}],"tags":[{"name":"awk","slug":"awk","permalink":"https://zpliu1126.github.io/Blog/tags/awk/"},{"name":"sed","slug":"sed","permalink":"https://zpliu1126.github.io/Blog/tags/sed/"}]},{"title":"基因家族分析流程","slug":"基因家族分析流程","date":"2019-03-12T07:55:35.000Z","updated":"2019-03-23T08:50:51.695Z","comments":true,"path":"archives/ba1fe7ba.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/ba1fe7ba.html","excerpt":"","text":"家族基因聚类分析流程首先获取到各个物种中对应的基因编号，并且得到对应的基因序列、氨基酸序列 序列保守性使用MEGA软件进行进化分析，提取各个物种中的氨基酸序列进行比对;MEGA中Alig by ClustalW 子程序得到结果如下: 进行聚类分析使用上一步比对好的mas后缀输出文件，构建进化树构建好进化树就可以输出树形状格式了，文件后缀为nwk (GhirD03G004880,Gorai.003G049300|CESA6),GhirA11G023630),); iTOL画进化树具体的学习方法花个1个小时的时间，看官网的视频就很清楚啦1.在cotrol面板中有所有的控制参数2.当需要添加数据集的时候，需要点击对应的分子进行添加，添加之后可以在控制面板进行参数的设置3.进行设置的时候可以使用粘贴功能 最后大功告成 Reference颜色搭配颜色搭配2iTOLEvolution进化树","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[]},{"title":"LDA线性判别分析","slug":"LAD线性判别分析","date":"2019-03-08T14:07:34.000Z","updated":"2019-03-11T10:11:26.540Z","comments":true,"path":"archives/3a6e9ae0.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/3a6e9ae0.html","excerpt":"","text":"LAD概括LAD主要用于在高维数据的分类中，将数据按照线性模型进行降维；使得数据得到很好的分类同时避免数据过度拟合，与PAC不同的是 LAD主要用于有监督的学习，用于对目标分类;约束条件则是类间的协方差最大，同类内的协方差最小化PAC则是无监督的学习，将样本投影到几个正交的方向，同时同类内的方差越大越好，尽可能的保留样本的全部信息 两类的LAD问题可以看作是把所有样本都投影到一个方向上，然后在这个一维空间中确定一个分类的阈值。过这个阈值点且与投影方向垂直的超平面就是两类的分类面。 公式推导 映射直线y=wTx 约束条件则是类间的协方差最大，同类内的协方差最小化 J=||wTμ0−wTμ1||22/wT(∑0+∑1)w=wT(μ0−μ1)(μ0−μ1)Tw/wT(∑0+∑1)w 这里涉及到欧氏距离也就是矩阵的平方等于 原矩阵*矩阵的转置 目的使得约束条件J最大化类间协方差矩阵 Sb=(μ0−μ1)(μ0−μ1)T类间协方差矩阵 Sw=∑x∈D0(x−μ0)(x−u0)T+∑x∈D1(x−μ1)(x−u1)T重写J: J=wTSbw/wTSww 关于W的确定，由于分子分母是w的平方，已经将w实数化；因此方程的解与w的大小已经无关，仅仅是方向上有关了 拉格朗日乘子法令wTSww=1c(w)=wTSbw−λ(wTSww−1)涉及到矩阵的求导dc/dw=2Sbw−2λSww=0Sbw=λSwwSbW 类间散度矩阵 方向是固定的U0-U1w=Sw -1(u0-u1) 基于两个以上特征值的分类原理是一样的，在计算类间散度矩阵是多了两个参数SB=∑i=1-c Ni(mmi−mm)(mmi−mm)Tmm 是全局均值，而 mmi 和 Ni 是每类样本的均值和样本数。 求出特征值和特征序列矩阵 S−1WSB =W按照特征值排序，将原来多维度的空间映射到对应的空间 代码实现数据获取与格式整理#coding=UTF-8 import numpy as np import pandas as pd from sklearn.preprocessing import LabelEncoder from matplotlib import pyplot as plt ####构造索引与对应的名称关系 feature_dict = {i:label for i,label in zip( range(4), (&#39;sepal length in cm&#39;, &#39;sepal width in cm&#39;, &#39;petal length in cm&#39;, &#39;petal width in cm&#39;, ))} &#39;&#39;&#39; {0: &#39;sepal length in cm&#39;, 1: &#39;sepal width in cm&#39;, 2: &#39;petal length in cm&#39;, 3: &#39;petal width in cm&#39;} &#39;&#39;&#39; ##读取数据 df=pd.io.parsers.read_csv( filepath_or_buffer=&#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;, header=None, sep=&#39;,&#39;, ) ###定义列名 df.columns=[l for i,l in sorted(feature_dict.items())]+[&quot;classLab&quot;] #删除文件末尾的空行 df.dropna(how=&quot;all&quot;,inplace=True) ###看一下最后10行时啥样 #print(df.tail()) &#39;&#39;&#39; sepal length in cm sepal width in cm petal length in cm \\ 145 6.7 3.0 5.2 146 6.3 2.5 5.0 147 6.5 3.0 5.2 148 6.2 3.4 5.4 149 5.9 3.0 5.1 petal width in cm classLab 145 2.3 Iris-virginica 146 1.9 Iris-virginica 147 2.0 Iris-virginica 148 2.3 Iris-virginica 149 1.8 Iris-virginica &#39;&#39;&#39; 将类别数字化X=df[[0,1,2,3]].values #获取四种属性值 y=df[&#39;classLab&#39;].values #获取类别名 enc = LabelEncoder() label_encoder = enc.fit(y) y = label_encoder.transform(y) + 1 label_dict = {1: &#39;Setosa&#39;, 2: &#39;Versicolor&#39;, 3:&#39;Virginica&#39;} # print(len(y)) &#39;&#39;&#39; 数据处理完成 计算每类花对应的特征值的均值##分别对三种花求其在4种属性上的均值 np.set_printoptions(precision=4) mean_vectors=[] for i in range(1,4): ##对4中属性150 X 4 的矩阵按列求均值 mean_vectors.append(np.mean(X[y==i],axis=0)) #print(&#39;mean Vector calss %s: %s\\n&#39; %(i,mean_vectors[i-1])) &#39;&#39;&#39; mean Vector calss 1: [5.006 3.418 1.464 0.244] mean Vector calss 2: [5.936 2.77 4.26 1.326] mean Vector calss 3: [6.588 2.974 5.552 2.026] &#39;&#39;&#39; 类内散度矩阵S_W=np.zeros((4,4)) for cl,mv in zip(range(1,4),mean_vectors): ####每个类的类内散度矩阵 class_sc_mat=np.zeros((4,4)) for row in X[y==cl]: ##把对应的值与特征值进行运算 &#39;&#39;&#39; [1,第一个特征值 2, 第2个特征值 3, 第3个特征值 4 第4个特征值 ] &#39;&#39;&#39; row, mv = row.reshape(4,1), mv.reshape(4,1) class_sc_mat+=(row-mv).dot((row-mv).T) S_W+=class_sc_mat 类间散度矩阵overall_mean=np.mean(X,axis=0) S_b=np.zeros((4,4)) for i,men_vector in enumerate(mean_vectors): ###获取样本数目 n=X[y==i+1,:].shape[0] men_vector=men_vector.reshape(4,1) overall_mean=overall_mean.reshape(4,1) S_b+=n*(men_vector-overall_mean).dot((men_vector- overall_mean).T) print(&#39;between-class Scatter Matrix:\\n&#39;, S_b) 获取特征值和特征向量eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(S_W).dot(S_b)) for i in range(len(eig_vals)): eigvec_sc = eig_vecs[:,i].reshape(4,1) print(&#39;\\nEigenvector {}: \\n{}&#39;.format(i+1, eigvec_sc.real)) print(&#39;Eigenvalue {:}: {:.2e}&#39;.format(i+1, eig_vals[i].real)) 根据特征值大小选取特征向量降维eig_pairs = [(np.abs(eig_vals[i]), eig_vecs[:,i]) for i in range(len(eig_vals))] eig_pairs = sorted(eig_pairs, key=lambda k: k[0], reverse=True) W = np.hstack((eig_pairs[0][1].reshape(4,1), eig_pairs[1][1].reshape(4,1))) 映射到新的空间X_lda = X.dot(W) assert X_lda.shape == (150,2) 作图def plot_step_lda(): ax = plt.subplot(111) for label,marker,color in zip( range(1,4),(&#39;^&#39;, &#39;s&#39;, &#39;o&#39;),(&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;)): plt.scatter(x=X_lda[:,0].real[y == label], y=X_lda[:,1].real[y == label], marker=marker, color=color, alpha=0.5, label=label_dict[label] ) plt.xlabel(&#39;LD1&#39;) plt.ylabel(&#39;LD2&#39;) leg = plt.legend(loc=&#39;upper right&#39;, fancybox=True) leg.get_frame().set_alpha(0.5) plt.title(&#39;LDA: Iris projection onto the first 2 linear discriminants&#39;) # hide axis ticks plt.tick_params(axis=&quot;both&quot;, which=&quot;both&quot;, bottom=&quot;off&quot;, top=&quot;off&quot;, labelbottom=&quot;on&quot;, left=&quot;off&quot;, right=&quot;off&quot;, labelleft=&quot;on&quot;) # remove axis spines ax.spines[&quot;top&quot;].set_visible(False) ax.spines[&quot;right&quot;].set_visible(False) ax.spines[&quot;bottom&quot;].set_visible(False) ax.spines[&quot;left&quot;].set_visible(False) plt.grid() plt.tight_layout plt.savefig(&quot;LDA.png&quot;) plot_step_lda() Reference推荐看老外的英文介绍老外的翻译版机器学习-线性判别分析.周志华xLAC拉格朗日乘子法PAC二分类LAD","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"实验进展","slug":"实验进展","date":"2019-03-08T03:05:44.000Z","updated":"2019-03-10T16:09:28.263Z","comments":true,"path":"archives/e5775d07.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/e5775d07.html","excerpt":"","text":"2019-03-10各个组织间表达模式分析基于前面的4中分类，我又分别对每一类进行了更细致的划分 相同亚基因组(A2 At Vs D5 Dt)在进化上角度上的比较 研究从祖先到后代的传递过程中，相对于祖先的状态是否发生了改变；这种改变在At和Dt的情况又是否一样呢 第一类中分为了不同的两类 第二类也分为了不同的两类 以此类推….. 不同亚基因组(A2 D5 Vs At Dt)在进化上角度上的比较 在祖先中原来两个分散的亚基因组，随着多倍化的事件在后代中聚合在一起,当At与Dt位于同一个细胞核内，是否对其各自的转录调控是否存在一定的影响呢 纤维发育的两个时期的表达模式 分别比较10DPA的fiber与20DPA的fiber在第一类(class1)和第二类(calss2)中表达的一致性 相同亚基因组的比较A2 At Vs D5 Dt class1class22. 不同亚基因组的比较A2 D5 Vs At Dtclass1class23. 对各个组织间表达一致的基因数目进行了统计- 相同亚基因组之间的比较 A2-At Vs D5-Dtcategoryleaf和fiber各个时期的ovuleleaf和petalcalss1class1_1306082class1_2524647calss2class2_192820class2_2132528class3class3_1160310348class3_2111161206class3_345115193class3_4110150246calss4375250408075- 不同亚基因组的比较 A2-D5 Vs At-Dtcategoryleaf和fiber各个时期的ovuleleaf和petalcalss1class1_166134117class1_2101138122calss2class2_1102525class2_2172425class3class3_1157218262class3_2106269189class3_3104250223class3_4206535312calss4431155887863 总结 维恩图只做了10DPA和20DPA的fiber的交集，因为佳琦的有fiber和leaf的DHS数据，我想同时对这三个组织进行分析，于是我对这三个组织也取了交集看一下，从上面两个表中也可以看到；再加上leaf组织取交集之后，表达一致的基因数目比维恩图中的数目少了不少 从这两个表来看，第二类在两个亚组间在多个组织都呈现相反的表达情况，似乎很少见这与我之前看到的文章差不多 2019-03-01分别对每一类在各个组织中的基因数目进行统计 关于各个组织间对应基因数目的统计 A2-D5 vs At-Dt 一共有18,689对亚基因组同源基因pairs，下图是各个组织中每种分类的基因对的数目 A2-At vs D5-Dt 对10天纤维和20天的纤维中的基因表达模式一致和不一致的进行了统计 其中每种颜色的link对应的一种表达模式，而灰色的则是表达模式在两个时期发生了改变 category 10fiber 20fiber Consistent calss1 1849 1572 772 calss2 996 965 330 class3 8224 8087 4864 class4 7620 8065 5368 Total 18,689 18,689 113,34 2019-02-27基因表达模式分类 在亚基因组同源基因表达模式分析中从两个角度进行分析 祖先到后代过程中，同一个基因组发生的变化例如 A2-At vs D5-Dt 祖先到后代过程中，亚基因组之间的变化 A2-D5 vs At-Dt 基于以上思想分别从这两个角度对这四个基因组的同源基因的表达模式进行分类分类的模式如下 category A2-At Vs D5-Dt A2-D5 Vs At-Dt calss1 At&gt;A2 vs Dt&gt;D5 At&lt;A2 vs Dt&lt;D5 A2&gt;D5 vs At&gt;Dt A2&lt;D5 vs At&lt;Dt class2 Dt&gt;D5 vs At&lt;A2 At&gt;A2 vs Dt&lt;D5 A2&gt;D5 vs At&lt;Dt At&gt;Dt vs A2&lt;D5 class3 At!=A2 vs Dt=D5 At=A2 vs Dt!=D5 A2=D5 vs At!=Dt A2!=D5 vs At=Dt class4 At=A2 Dt=D5 A2=D5 At=Dt 任选其中的一个角度去解释这种分类的意义 class1中At大于A2 Dt&gt;D5与祖先相比At Dt两个基因组是相同的变化calss2中At大于A2 Dt小于D5 At与Dt在于祖先的比较中是相反的变化class3中At或Dt中的一个基因组与祖先相比没有变化calss4中At与Dt与祖先相比都没有变化 对于A2 D5 Vs At Dt 同样可以做这种解释 作图基于这种分类，画出在各个组织中对应的差异倍数的均值 从A2 D5 Vs At Dt 的角度作图 从A2 At Vs D5 Dt 的角度作图也是同样的 图中颜色相同的线表示的是同一种亚基因组同源基因 图1中两条红色线，和旁边的图例分别表示 在Ancestor中A2&gt;D5;在posterity后代中At&gt;Dt 通过性状区分Ancestor与posterity，而颜色相同表示它们是同一组亚基因组同源基因对A2-D5-At-Dt 参考维恩图2维恩图2维恩图3","categories":[],"tags":[]},{"title":"梯度上升算法实现","slug":"梯度上升算法实现","date":"2019-03-07T07:43:06.000Z","updated":"2019-03-07T08:12:32.188Z","comments":true,"path":"archives/1df1d0ad.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/1df1d0ad.html","excerpt":"","text":"梯度上升算法概念例如我们存在一个函数 f(x)=X2+4x要求它的极值，主要就是求偏导为0的那个点的坐标像这种简单的函数直接使f(x)‘为0就行 但在真实的情况中函数没有我们想象的这么简单，那就只能让我们一步一步的逼近极值点 X i+1=X i+a*f(x)‘ a为步长控制更新的幅度，当函数值无限逼近极值点时停止迭代过程 代码实现#coding=UTF-8 &#39;&#39;&#39; 梯度上升算法的简单实现 原函数 f(x)=x2+4x &#39;&#39;&#39; def Gradient(): ##定义导函数 def gradientPrim(X): return -2*X+4 x_old=1 x_new=0 ###控制步长度 alpha=0.01 #####控制梯度阈值 presision=0.0000001 while abs(x_new-x_old)&gt;presision: x_old=x_new #将提升后的值代入导函数求得新的坐标点； #当导函数无限的笔记0的时候，x_old与x_new也就无限逼近了 x_new=x_old+alpha*gradientPrim(x_old) print(x_new) Gradient() 总结 梯度上升与梯度下降算法主要的一个思想 当函数达到极值点时，导函数为0,这时新的坐标点与旧的坐标点之间的距离将无限的逼近 逼近的精度受到判断指标presision影响 同时步长主要影响的是迭代的次数 参考https://blog.csdn.net/c406495762/article/details/77723333","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"logistic回归","slug":"logistic回归","date":"2019-03-07T06:38:42.000Z","updated":"2019-03-09T14:54:56.988Z","comments":true,"path":"archives/b10b3e49.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/b10b3e49.html","excerpt":"","text":"概念 logistics回归是一种二分类的算法，它利用sigmoid函数将样本数据映射在[0,1]空间 假设我们的一个样本有n个属性x 1…x n,那就需要有n个参数构成的矩阵，将其构造成一个线性模型 对每一个样本我们都可以使用这个参数矩阵去计算一个条件概率； P(y=1|x,w)=0.51P(y=1|x,w)=0.99同一个样本在不同的参数矩阵w下，对样本估计为1的概率不同，我们需要取得最大的概率 扩展到整个样本， 又因为样本之间是独立同分布的，就可以用每个样本的概率做累乘 做完乘法之后将会得到一个关于w矩阵的概率函数，我们训练的目的就是要寻找一组w参数来使得我们正确判断y=1与y=0的概率达到最大 关于累乘的求导，通常使用ln函数变成累加，方便计算 这就回到了对函数求极值点的问题了，数据已经有了接下来就是要梯度法进行求解就行 在梯度下降过程中使用矢量法进行替换求解公式推导 矢量化在利用梯度求解过程中使用到矢量化的思想 在迭代的过程中设置w参数的初始值为 n x 1 的矩阵 接下来往公式里套就行了代码实现 #ocding=UTF-8 ### #罗杰斯特回归 ## import numpy as np ##读取文件数据 # # def loadDataSet(): dataMat=[] labelMat=[] fr=open(&quot;testSet.txt&quot;) for line in fr.readlines(): linerArr=line.strip().split() dataMat.append([1,float(linerArr[0]),float(linerArr[1])]) labelMat.append(int(linerArr[2])) fr.close() return(dataMat,labelMat) def sigmoid(x): return(1.0/(1+np.exp(-x))) ####梯度上升法#### def gradAscent(dataMatin,labelMatin): dataMatout=np.mat(dataMatin) labelMatout=np.mat(labelMatin).transpose() m,n=np.shape(dataMatout) alpha=0.001 maxCycle=500 ###初始参数的矩阵 weights=np.ones((n,1)) for k in range(maxCycle): ##这里已经把累加算了，得到m x 1矩阵 h=sigmoid(dataMatout*weights) error=labelMatout-h #####把x矩阵转置构造 n x m 矩阵 weights=weights+alpha*dataMatout.transpose()*error return weights dataMat,labelMat=loadDataSet() print(gradAscent(dataMat,labelMat)) 参考https://blog.csdn.net/lgb_love/article/details/80592147https://blog.csdn.net/c406495762/article/details/77723333最大似然法矢量化","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"高斯消元法","slug":"高斯消元法","date":"2019-03-07T05:49:01.000Z","updated":"2019-03-09T15:06:05.314Z","comments":true,"path":"archives/eccd8894.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/eccd8894.html","excerpt":"","text":"高斯消元法介绍 高斯消元法主要用在解线性方程，当前实现的仅仅是有唯一解的一个算法 x1 x2 x3 val 1 2 3 5 3 4 4 7 3 4 5 6 将线性方程变成一个上三角矩阵的过程1 2 3 3 40 1 2 3 40 0 1 2 30 0 0 3 3 从这个矩阵也不难看出是一个n x (n+1)类型 实现步骤 实现上三角转换主要是进行遍历，遍历的过程主要就是让每行的参数变为0 第一行遍历剩下的n-1行第二行遍历剩下的n-2行 所有行都遍历 上三角转换后，计算参数这里可以利用 n x (n+1)这一特性 源代码#coding=UTF-8 ###高斯消元法实现######### def Gauss(data): ##i是列元素j是控制循环的次数，line是存储一行元素 i=0 j=0 line_size=len(data) while j&lt;line_size-1: ###得到数据中的行 line=data[j] temp=data[j][j] templete=[] for x in line: x=x/temp templete.append(x) data[j]=templete flag=j+1 ######遍历第1行以后的行 while flag&lt;line_size: templete1=[] temp1=data[flag][j] i=0 ####将行的每一个元素与第一行相减 for x1 in data[flag]: if x1 !=0: x1=x1-(temp1*templete[i]) templete1.append(x1) else: templete1.append(0) i+=1 data[flag]=templete1 flag+=1 ##第一个参数已经消去，遍历消去剩下的参数 j+=1 #################对得到的上三角矩阵计算参数########### &#39;&#39;&#39; [1,2,3,4,5 0,2,3,4,5 0,0,4,5,6 0,0,0,1,3 ] &#39;&#39;&#39; parameter=[] parameter.append(data[line_size-1][-1]/data[line_size-1][-2]) ##parameter的下标刚好是所有参数剪切 #####从倒数第二列开始计算参数# i=line_size-2 while i &gt;=0: sum=0 parameter1=0 #这里分别进行回带，通过paramete数组 for j in range(i+1,line_size): sum+=parameter[line_size-1-j]*data[i][j] parameter1=(data[i][-1]-sum)/data[i][i] parameter.append(parameter1) i=i-1 return(parameter) #####进行消元测试####### parameters=[ [6,15, 55,152.6], [15, 55, 225, 585.6], [55,225,979,2488.8] ] results=Gauss(parameters) print(&quot;x1=&quot;+str(results[-1])+&quot;\\nx2=&quot;+str(results[-2])+&quot;\\nx3=&quot;+str(results[0])+&quot;\\n&quot;) 总结其实思想很简单，代码实现的时候有一些小技巧 关于python画图的画等有时间再进行摸索吧 参考 https://blog.csdn.net/deramer1/article/details/79049625","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"最小二乘python实现","slug":"最小二乘python实现","date":"2019-03-06T14:26:52.000Z","updated":"2019-03-09T14:58:29.821Z","comments":true,"path":"archives/6c33c6ae.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/6c33c6ae.html","excerpt":"","text":"什么是最小二乘法通常用来对改定数据集D做线性回归，找到一条最逼近整个数据集的直线；在这里我只使用了一个属性到y的映射，其实也有多个属性可以同时进行映射，就需要用到降维的思想，例如我们有一对刮南瓜、西瓜、黄瓜；既可以使用三个坐标系将它们进行刻画。 让拟合直线上的每一个点距离D中的点的离均差的误差最小 Σ1m(f(xi)-yi)2 推理步骤 当所有样本到直线上的点最小时，相当于对K和b求偏导为0 分别对k和b的公式进行转换，得到k和b的值 我发现它必定要过（x,y）的平均值的那个点 python实现#coding=UTF-8 &#39;&#39;&#39; 进行一元数据的拟合 &#39;&#39;&#39; x=[1,2,3,4,5,6,7] y=[3,4,5,6,7,8,9] ###计算拟合参数###### def lineFitting(data_x,data_y): ###获取集合中样本数目 size=len(data_x) ##构造遍历索引变量 i=0 ###声明公式中的变量 sum_x=0 sum_y=0 sum_Xsquare=0 sum_xy=0 average_x=0 average_y=0 ######对各个变量进行赋值 while i&lt;size: sum_x+=data_x[i] sum_y+=data_y[i] sum_Xsquare+=data_x[i]*data_x[i] sum_xy+=data_x[i]*data_y[i] i+=1 average_x=sum_x/size average_y=sum_y/size ###获取各个参数后直接套公式#### k=(sum_xy-sum_y*average_x)/(sum_Xsquare-sum_x*average_x) b=average_y-k*average_x return [k,b] #########计算拟合后的参数######### fittingParameter=lineFitting(x,y) print(&quot;y=&quot;+str(fittingParameter[0])+&quot;*x&quot;+&quot;+&quot;+str(fittingParameter[1])+&quot;\\n&quot;) 绘图最后本来打算画一个图的，但是在服务器上跑脚本，图片就算了吧","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zpliu1126.github.io/Blog/tags/python/"}]},{"title":"【持续更新】关于hexo博客的搭建","slug":"关于hexo博客的搭建","date":"2019-03-05T10:06:07.000Z","updated":"2019-03-25T14:05:29.241Z","comments":true,"path":"archives/d86fd5e9.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/d86fd5e9.html","excerpt":"","text":"Quick start关于如何进行安装hexo和一些配置插件的过程我这里就不详细介绍了；大家可以百度网上一大堆，当然我这里推荐一些讲的比较好的博客遇见西门里面介绍了如何进行hexo的安装与主题的优化 插件的配置我使用的是gitment，还是对github比较有好感，具体教程参考：gitment 永久链接的配置借助于hexo-abbrlink插件，安装好之后呢；在博客目录下的配置文件中修改_config.yml文件就ok，具体的修改方式如下 permalink: archives/:abbrlink.html abbrlink: alg: crc32 rep: hex 参考 关于在github二级仓库中构建博客 首先是在博客目录下的配置文件中进行设置url: https://zpliu1126.github.io/hexoTest root: /hexoTest/ 接着就是关于搜素插件如何找到对应文件路径设置/*#######设置数据库所在文件*/ xhr.open(&#39;GET&#39;, &#39;/hexoTest/content.json&#39;, true); 由于该主题作者 Snippet并没有考虑到这一情况，我是在获取conten.js的路径中进行了修改 对应找到对应的数据文件之后进行路径的构造/*关于在搜素结果content.json获取数据后加上子repository名构造最后url*/ path: &quot;hexoTest/&quot;+post.path, 其实就是一个字符串拼接的过程 关于文章如何进行分类的问题 1.在theme配置文件中打开category和tag标签 2.接着在每一个生成的文章中需要定义好category和tag内容才能进行跳转 3.同时在theme配置文件中可以定义好一些目录的跳转链接 #########文章的开头########## --- title: 关于hexo博客的搭建 abbrlink: d86fd5e9 date: 2019-03-05 18:06:07 category: computerLanguage tag: - JavaScript - html - css --- ######导航栏########## menu: - page: home url: /hexoTest icon: - page: 计算机程序 url: /hexoTest/categories/computerLanguage/ icon: - page: Bioinformatic url: /hexoTest/categories/Bioinformatic/ 添加背景音乐 首先在网页版网易云找到喜欢的音乐，点击添加外部播放器有html和flash版本 我选择html版本，然后在theme的部署文件里随便找了个地方放了进去 最后调整播放框的大小 文章加密访问 基于插件访问 hexo-blog-encrypt 修改根目录配置文件 Security encrypt: enable: true 在文章头部加上password字段图片放大的插件 首先得依赖于jauery1.11.1版本，我试的1.13.1版本不合适 关于图片的触发，在img标签中加上class=pimg 最后是触发后的位置需要进行承载承载我写了一个div class=Bigimglocation标签进行承载 在触发的js中加入$(.Bigimglocation).load(“承载的html”) 最后只需加上在img标签中class=pimg 并加上承载类&lt;img class=&quot;pimg&quot; src=&quot;&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;Bigimglocation&quot;&gt;&lt;/div&gt; 代码高亮 首先在head标签内引入css和js代码 在copyright区域触发 这里在我的主题下还存在一些行号冲突的问题，于是我干脆就直接把主题自带的css文件定义好的行号标签修改 display: none;修改后的高亮，看起来舒服多了 唯一的缺点就是代码的高亮可能会存在一定的延迟&lt;script type=&quot;text/javascript&quot;&gt; // Say hello world until the user starts questioning // the meaningfulness of their existence. function helloWorld(world) { for (var i = 42; --i &gt;= 0;) { alert(&#39;Hello &#39; + String(world)); } } &lt;/script&gt; &lt;style&gt; p { color: pink } b { color: blue } u { color: &quot;umber&quot; } &lt;/style&gt; 我部署到网站之后与本地的效果还是有一些出入 稍作修改，对 margin:0;参数改一下就行了;同时将要写代码的地方空一行，不这样有可能发生错误 将网站推送到搜素引擎SEO 由于百度爬虫太疯狂，影响了github的用户体验，因此百度爬虫被github封了基于这种考虑，我将github推送到Google SEO同时在codingme 也建了一个类似的站，就让百度爬取codingme上的内容；内容同时发布在两个网站上 百度SEO提交Google SEO提交博客根目录配置信息 deploy: type: git repo: github: git@github.com:zpliu1126/Blog.git,gh-pages coding: git@git.dev.tencent.com:zpliu1126/Blog.git,master 参考文章加密图片放大代码高亮代码漂亮的主题代码配色SEO推送阿里图标","categories":[{"name":"computerLanguage","slug":"computerLanguage","permalink":"https://zpliu1126.github.io/Blog/categories/computerLanguage/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zpliu1126.github.io/Blog/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://zpliu1126.github.io/Blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://zpliu1126.github.io/Blog/tags/css/"}]},{"title":"本地Blast教程","slug":"本地Blast教程","date":"2019-03-05T10:04:50.000Z","updated":"2019-03-06T01:30:49.638Z","comments":true,"path":"archives/d57c3785.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/d57c3785.html","excerpt":"","text":"blast+安装 通过wget 命令直接下载到本地服务器中wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/ncbi-blast-2.2.30+-x64-linux.tar.gz 对下载好的文件进行解压tar -zxvf ncbi-blast-2.2.30+-x64-linux.tar.gz 解压之后，其实就可以使用绝对路径使用blast+了；怎么知道blast的绝对路径呢pwd ncbi-blast-2.2.30+-x64-linux.tar.gz/bin ######例如我们得到这样的绝对路径########## /home/local/software/ncbi-blast-2.2.30+-x64-linux/bin/ 这条命令就得到了我们blast可执行程序所在的绝对路径，也就是在电脑上的哪个文件夹 有了绝对路径我们就可以告诉计算机到哪里去找balst程序来执行当执行blastn核苷酸比对程序时直接使用下面的命令就可以执行了/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin/blastn 添加可执行程序到环境变量中 首先环境变量是啥？环境变量其实就是一个变量，这个变量里面包括一个叫$PATH的变量，里面存储着一些你想告诉计算机的东西。比如我想告诉计算机blast+的所有可执行的程序都放在哪个文件里面，我只需要在$PATH这个变量中加上blast/bin的文件夹；这样当我们在计算机的任何地方想要执行balst的时候只需要按下blastn或者其他命令就行了echo &quot;export PATH=/home/local/software/ncbi-blast-2.2.30+-x64-linux/bin:\\$PATH&quot; &gt;&gt; ~/.bashrc source ~/.bashrc blast的使用构建本地blast库例如要构建核酸库，使用整个CDS构建的基因序列库makeblastdb -in &quot;CDS文件&quot; -dbtype &quot;nucl&quot; -parse_seqids -out &quot;库名称的前缀&quot; 具体参数的意义可以使用 -help参数查看手册，我就不多做赘述同理构建蛋白库makeblastdb -in &quot;氨基酸序列文件&quot; -dbtype &quot;prot&quot; -parse_seqids -out &quot;库名称的前缀&quot; 进行序列比对 首先我们需要准备比对的fasta文件，然后一条命令就可以了blastn -query &quot;需要比对的文件&quot; -db &quot;上一步建好的库的目录加上/库前缀&quot; -evalue 1e-5 -outfmt 6 -out &quot;输出文件&quot; 这里的outfmt是输出文件的格式，包括1-10种格式 具体参数的意义，可以使用–help参数查看","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[{"name":"Blast","slug":"Blast","permalink":"https://zpliu1126.github.io/Blog/tags/Blast/"}]},{"title":"模型评估与选择","slug":"模型评估与选择","date":"2019-03-05T09:49:35.000Z","updated":"2019-03-05T09:52:03.231Z","comments":true,"path":"archives/7d1dcda7.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/7d1dcda7.html","excerpt":"","text":"","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://zpliu1126.github.io/Blog/categories/MachineLearning/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://zpliu1126.github.io/Blog/tags/基础/"}]},{"title":"Linux基础篇","slug":"Linux","date":"2019-03-05T09:46:11.000Z","updated":"2019-04-03T14:43:10.621Z","comments":true,"path":"archives/53d0684b.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/53d0684b.html","excerpt":"","text":"","categories":[{"name":"computerLanguage","slug":"computerLanguage","permalink":"https://zpliu1126.github.io/Blog/categories/computerLanguage/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zpliu1126.github.io/Blog/tags/Linux/"}]},{"title":"Circos进阶","slug":"Circos其实很简单","date":"2019-03-05T09:40:46.000Z","updated":"2019-03-18T13:18:49.129Z","comments":true,"path":"archives/87ef918.html","link":"","permalink":"https://zpliu1126.github.io/Blog/archives/87ef918.html","excerpt":"","text":"ideogram间距有两种设置方法 所有ideogram同时设置，在spacing标签内使用default属性 对相邻的两条进行设置，在pairwise中进行设置 &lt;ideogram&gt; &lt;spacing&gt; default = 10u &lt;pairwise hs1&gt; spacing = 5u &lt;/pairwise&gt; &lt;pairwise hs3 hs4&gt; spacing = 0.25r &lt;/pairwise&gt; &lt;/spacing&gt; &lt;/ideogram&gt; 颜色设置 在colors标签内自定义颜色 ##在mycolors.conf中定义 Atcolor=25,181,254 Acolor=0,230,64 Dtcolor=240,255,0 Dcolor=242,38,19 ## 在主文件circos.conf的colors标签内引用 &lt;colors&gt; &lt;&lt;include mycolors.conf&gt;&gt; &lt;/colors&gt; 自定义的颜色就可以使用了，例如我使用自定义颜色修饰染色体 chr - At02 At02 0 108049532 Atcolor chr - Dt13 Dt13 0 63316526 Dtcolor chr - A02 A02 0 99090824 Acolor chr - D12 D12 0 35429946 Dcolor 在circos.conf中使用rgb()函数自定义颜色， &lt;link&gt; file=data/At_AC.txt radius=0.95r bezider_radius=1.5r thickness=3 color=rgb(140,20,252) z=20 &lt;/link&gt; links让color颜色与第二个连接点的颜色相同 color=eval(var(chr2)) eval函数与大多数语言中的功能类似，在bash中eval会执行字符串表示的命令 link有时候会缠绕在一块就像下面这样这时候只需要把对应的染色体翻转一下就行啦！ chromosomes_reverse=At13;D04;D11;D10;D09;A07;A05;A08; ###两条线交叉的时候可以考虑把染色体顺序换一下 chromosomes_order=At01,At02,At03,At04,At05,At06, link中的rule规则 取从哪条染色体开始 &lt;rule&gt; condition=from(Chr03) color=rgb(247,202,24) &lt;/rule&gt; ###到哪条染色体结束 &lt;rule&gt; condition=to(Chr03) color=rgb(247,202,24) &lt;/rule&gt; 给不同的link上色，在数据文件中就事先区分好数据文件如下 chr10class4 1 10000 chr20class4 1 10000 value=class4_1 chr10class3 7250 7260 chr20class3 7250 72600 value=class3_3 同过value变量进行自定义上色 &lt;rule&gt; condition= var(value) eq &quot;class1_1&quot; color=red &lt;/rule&gt; 这里有一定需要注意，这和perl中的判断一样：字符串使用 eq 数字使用==，我在这里就犯错了 link如何弯曲控制曲线的弯曲程度有多个参数，其中一个是bezier_radius bezier_radius=1.0r 添加注释信息例如在染色体对应的位置添加对应的基因编号信息,首先得准备对应的数据文件text.txt A02 38395050 38401512 Ga02G0753.1 A05 916845 922879 Ga05G0093.1 A05 929480 933564 Ga05G0095.1 A05 977266 983344 Ga05G0100.1 A05 14673170 14690147 Ga05G1638.1 A06 56575979 56582045 Ga06G1315.1 在circos.conf中的plots标签内定义type=text &lt;plots&gt; type=text r0=1.05r r1=1.1r+400p show_links=yes link_dims=4p,4p,8p,4p,4p link_thickness=2p label_size=24p color=red label_font=condensed padding=0p rpadding=0p &lt;plot&gt; file=data/textAt.txt color=rgb(25,181,254) &lt;/plot&gt; &lt;/plots&gt; 具体参数的意义: histogram柱状图 数据文件格式如下：染色体位置+柱状图的大小 CA_chr1 109361328 109659167 9 CA_chr1 137401104 137443513 8 CA_chr1 134830783 135785508 48 CA_chr1 135908705 136353163 24 CA_chr1 61257167 61388884 8 CA_chr1 56197340 56261821 6 CA_chr1 117275800 117755122 12 CA_chr1 123325601 123882451 8 CA_chr1 58923028 59194595 8 CA_chr1 47239752 47399584 7 CA_chr1 66213515 67537745 49 有时候为了让边框没有颜色，可以考虑把thickness设置为0 &lt;plots&gt; r0=0.9r r1=0.97r color=red thickness=0 &lt;plot&gt; type=histogram file=data/Ahighlight.txt fill_color=rgb(255,203,5) &lt;/plot&gt;","categories":[{"name":"Bioinformatic","slug":"Bioinformatic","permalink":"https://zpliu1126.github.io/Blog/categories/Bioinformatic/"}],"tags":[{"name":"Circos学习","slug":"Circos学习","permalink":"https://zpliu1126.github.io/Blog/tags/Circos学习/"}]}]}